<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=UTF-8" http-equiv="content-type">
  <meta name="description" content="PLF C++ Library - plf::colony">
  <meta name="keywords"
  content="C++, C, vector, colony, plf::colony, speed, OO, containers, optimize, performance, pointer, iterator, invalidation, benchmarks, results, benchmark, vs, versus, std::list, std::map, std::multiset, std::vector, std::deque, deque, segmented_tree">
  <title>PLF C++ Library - plf::colony</title>
  <link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>
<a href="index.htm">Home</a> 

<h1>PLF C++ Library - plf::colony</h1>
<ul>
  <li><a href="#intro">Intro</a></li>
  <li><a href="#details">Implementation</a></li>
  <li><a href="#license">License</a></li>
  <li><a href="#download">Download</a></li>
  <li><a href="#functions">Function Descriptions and Syntax</a></li>
  <li><a href="#benchmarks">Benchmarks</a></li>
  <li><a href="#faq">Frequently-asked Questions</a></li>
  <li><a href="#version">Version History</a></li>
  <li><a href="#contact">Contact</a></li>
</ul>

<h2><a id="intro"></a>Introduction</h2>

<p>A colony is a C++ template-based unordered data container which provides
better performance than any std:: library container when:</p>
<ol type="a">
  <li>Insertions and erasures to the container are occuring frequently in
    realtime ie. in performance-critical code, <i><b>and/or</b></i> </li>
  <li>Pointers or iterators which point to non-erased container elements must
    not be invalidated by insertion or erasure.</li>
</ol>

<p>While the benchmarks in the section below are a better area to get a feel
for the performance benefits, the general speed characteristics are:</p>
<ul>
  <li><i>Insertion</i>: better than any std:: library container except good
    implementations of deque.</li>
  <li><i>Erasure</i>: better than any std:: library container.</li>
  <li><i>Iteration</i>: better than any std:: library container where pointer
    validity is important. Where pointer validity is unimportant, better than
    any std:: library container except deque and vector.</li>
</ul>

<p>As explored further in the benchmarks there are some <a
href="#comparative_tests">vector/deque modifications</a> which can outperform
during iteration while maintaining pointer validity, but at a cost to usability
and memory use. Colony has other advantages including the freeing and recycling
of unused memory on-the-fly, the guaranteed stability of
pointers/references/iterators to non-erased elements (which makes programming
with containers of interrelated data structures faster and much easier), and
broad cross-compiler support.</p>

<p>It can be reasonably compared to a "bag" or "bucket-array" styled structure,
where each element location can be emptied and skipped over. Unlike a bucket
array it does not use keys, iterates faster due to the use of a <a
href="http://www.mediafire.com/download/qpy18jp4jbli7jc/the_jump_counting_skipfield_pattern.pdf">jump-counting
skipfield</a> instead of a boolean field, and frees or recycles unused memory
from erased element locations on the fly. As it was initially developed
predominantly for game development, colony favours small and large struct/class
performance over scalar-type (float, int, etc) performance.</p>

<h2><a id="motivation"></a>Motivation</h2>
<p>When working on video game engines we are predominantly dealing with collections of data where:<Br>
(<i>Note: These requirements match other areas of software development as well, but to simplify discussion I will focus on video game development</i>)</p>
<ol type="a">
<li>Elements within data collections refer to elements within other data collections (through a variety of methods - indices, pointers, etc). An example is a game entity referring to both a texture object and collision blocks, as well as sound data. These references must stay valid throughout the course of the game/level. For this reason, any container (or use of a container) which causes pointer or index invalidation can create difficulties or necessitate workarounds.</li>
<li>Order is unimportant for the most part. The majority of data collections are simply iterated over, transformed, referred to and utilized with         no regard to order.</li>
<li>Storage of small-to-medium-sized classes and structs is the norm. Work with collections of small scalar types like int, double is far less common. Sometimes data can be stored in a SoA (Struct of Arrays) configuration, but these cases are somewhat less common.</li>
<li>Erasing or otherwise removing or deactivating objects occurs frequently in-game and in realtime (though often erasures will be implemented to occur at the end of a frame due to multithreading concerns). An example could be destroying a wall, or a game enemy. For this reason methods of erasure which create strong performance penalties are avoided.</li>
<li>Creating new objects and adding them into the gameworld on-the-fly is also common - for example, a tree which drops leaves every so often, or a quadtree.</li>
<li>We don't always know in advance how many elements there will be in a container at the beginning of development, or even at the beginning of a level during playback - an example of this being a MMORPG (massively multiplayer online role-playing game). In a MMORPG the number of game entities fluctuates based on how many players are playing, though there may be maximum capacity limits. Genericized game engines in particular have to adapt to considerably different user requirements and scopes. For this reason extensible containers which can expand and contract in realtime are usually necessary.</li>
<li>Depending on the complexity and scope of any given game, we can be dealing with anywhere between 10 and 100000 objects in a given area. We are not typically dealing with the types of capacities necessitated by large-scale mathematical or statistical applications.</li>
<li>For performance reasons, memory storage which is more-or-less contiguous is preferred. Lists, vectors of pointers to dynamically-allocated objects, and maps as implemented in the standard library are unusable.</li>
</ol>
<br>
<p>To meet these requirements, game developers tend to either (a) develop their own custom containers for given scenario or (b) develop workarounds for the failings of standard containers. These workarounds are many and varied, but the most common are probably:
<ol>
<li>Inserting all data at the beginning of a level then never adding to the data, whilst using a boolean flag (or similar) to indicate the inactivity of an object (as opposed to actually erasing from the vector). When erasing, one simply adjusts the boolean flag, and when iterating, items with the adjusted boolean flag are skipped.</li>
<li>Utilizing a vector of data with a secondary vector of indexes. When erasing, the erasure occurs on the vector of indexes, not the vector of data, and when iterating, one iterates over the vector of indexes, then accessing the data from the vector of data via the index.</li>
</ol>
<br>
<p>The first technique has the advantage of fast erasure and simplicity of use, but is comparablty slow to iterate over and never frees memory to the OS. The second technique still has somewhat slow erasure but fast iteration, and also never frees memory to the OS. The first technique disallows insertion on the fly, as this invalidates pointer references. The second can maintain external references upon subsequent insertions, but only if the external object referencing the data knows both the container and the index, which complicates implementation. In addition, insertions will be slow due to the vector's need to reallocate once reaching capacity.</p>

<p>Colony is an attempt to bring a better and more generic solution to this area of work. It has the advantage of fast iteration while maintaining the same extremely fast erasure speed of the boolean technique described above, and without causing pointer/iterator invalidation upon either erasure or insertion. It's insertion speed is also faster than a vector's. Memory from erased elements is either reused by subsequent insertions or released to the OS on-the-fly. It achieves these ends by via a number of new approaches: a <a
href="http://www.mediafire.com/download/qpy18jp4jbli7jc/the_jump_counting_skipfield_pattern.pdf">jump-counting
skipfield</a> (instead of a boolean field), a <a
href="chained_group_allocation_pattern.htm">linked chain</a> of increasingly-large memory blocks (instead of a singular memory block or vector of blocks), and a <a href="stack.htm">custom stack</a> (plf::stack) for memory location reuse.</p>

<p>More data on the performance characteristics of the colony versus other containers and workarounds can be found in the <a
href="#benchmarks">benchmarks section</a>, but read further below to get a grasp of the mechanics of this container.</p>

<h2><a id="details"></a>Implementation</h2>

<p>plf::colony uses a <a
href="chained_group_allocation_pattern.htm">chained-group memory allocation
pattern</a> with a growth factor of 2, (doubly-linked chains of element
"groups" containing memory blocks with additional structure metadata, including
in this case the jump-counting skipfield). While a growth factor of 2 gives the
best performance in the majority of scenarios (which is why the same growth
factor is used for the majority of vector implementations), in scenarios where
a smaller or more static increase is required, colony's minimum and maximum
group sizes can be adjusted to suit. This group-based approach removes the
necessity for data reallocation upon insertion, and because data is not
reallocated, all references/pointers/iterators to container elements stay valid
after insertions to the container.</p>

<p>Due to a std::vector being the most widely-used and commonly-understood of
the std:: library containers, we will now contrast the storage mechanisms of
colony with that of a std::vector:</p>
<img src="vector_addition.gif"
alt="Visual demonstration of inserting to a full vector" height="540"
width="960"> <img src="colony_addition.gif"
alt="Visual demonstration of inserting to a full colony" height="540"
width="960"> 

<p>The lack of reallocation also explains why insertion into a colony is faster
than insertion into a std::vector. Colony has two other internal mechanisms:
one is the jump-counting skipfield, utilising an array of 16-bit integers
corresponding to every element in the container, which enables the colony to
skip over erased elements during iteration. The second is a <a
href="stack.htm">plf::stack</a> of erased element locations for reuse during
subsequent insertion. When an element is erased in a std::vector, the following
happens:</p>
<img src="vector_erasure.gif"
alt="Visual demonstration of randomly erasing from a vector" height="540"
width="960"> 

<p>When an element is erased in a colony, this happens:</p>
<img src="colony_erasure.gif"
alt="Visual demonstration of randomly erasing from a colony" height="540"
width="960"> 

<p>This also explains the typical performance advantage you get when erasing
from a colony (variability based on element sizeof and amount of elements)
versus erasing from a std::vector.</p>

<p>Upon subsequent insertions to a colony following an erasure, the container
will check to see if erased location stack is empty. If it is empty, it inserts
to the end of the colony, creating a new group if the old group is full. If not
empty, it instead pops an erased element location off the stack and reuses that
location for the newly-inserted element. If you erase all the elements in any
given group in a colony, the group is removed from the colony's group chain and
it's erased element locations removed from the location stack.</p>

<h2><a id="license"></a>License</h2>

<p>plf::colony is under a permissive <a
href="http://en.wikipedia.org/wiki/Zlib_License">zlib license</a>. This means:
Software is used on 'as-is' basis. It can be modified and used in commercial
software. Authors are not liable for any damages arising from its use. The
distribution of a modified version of the software is subject to the following
restrictions:</p>
<ul>
  <li>The authorship of the original software must not be misrepresented,</li>
  <li>Altered source versions must not be misrepresented as being the original
    software, and</li>
  <li>The license notice must not be removed from source distributions.</li>
</ul>

<h2><a id="download"></a>Download</h2>

<p>Download <a href="plf_colony_11-06-2016.zip">here</a> (28kb zip file) or
view the <a
href="https://github.com/mattreecebentley/plf_colony">repository</a><br>
<br>
The colony library is a simple .h header file, to be included with a #include
command. The package includes the plf::stack .h file, which is used internally
by plf::colony.<br>
<br>
In addition if you are interested in benchmarking you can also download the <a
href="plf_benchmark_suite_30-05-2016.zip">plf benchmark suite</a> (37kb zip
file), which includes plf::nanotimer.</p>

<h2><a id="functions"></a>Function Descriptions and syntax</h2>

<p>Colony meets the requirements of the C++ <a
href="http://en.cppreference.com/w/cpp/concept/Container">Container</a>, <a
href="http://en.cppreference.com/w/cpp/concept/AllocatorAwareContainer">AllocatorAwareContainer</a>,
and <a
href="http://en.cppreference.com/w/cpp/concept/ReversibleContainer">ReversibleContainer</a>
concepts.</p>

<p>For the most part the syntax and semantics of colony functions are very
similar to all std:: c++ libraries. However there are a few key differences,
such as the meaning of using a number in the constructor. Formal description is
as follows:</p>
<code>template &lt;class T, class Allocator = std::allocator &lt;T&gt; &gt;
class colony</code> 

<p><code><b>T</b></code> - the element type. T must meet the requirements of <a
href="http://en.cppreference.com/w/cpp/concept/CopyAssignable">CopyAssignable</a>
and <a
href="http://en.cppreference.com/w/cpp/concept/CopyConstructible">CopyConstructible</a>.<br>
<code><b>Allocator</b></code> - an allocator that is used to acquire memory to
store the elements. The type must meet the requirements of <a
href="http://en.cppreference.com/w/cpp/concept/Allocator">Allocator</a>. The
behavior is undefined if <code>Allocator::value_type</code> is not the same as
T.</p>

<h4>Basic example of usage</h4>
<code><!-- HTML generated using hilite.me --></code> 

<div
style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;">
<pre style="margin: 0; line-height: 125%"><code><span style="color: #557799">#include &lt;iostream&gt;</span>
<span style="color: #557799">#include "plf_colony.h"</span>

<span style="color: #333399; font-weight: bold">int</span> <span style="color: #0066BB; font-weight: bold">main</span>(<span style="color: #333399; font-weight: bold">int</span> argc, <span style="color: #333399; font-weight: bold">char</span> <span style="color: #333333">**</span>argv)
{
  plf<span style="color: #333333">::</span>colony<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">int</span><span style="color: #333333">&gt;</span> i_colony;

  <span style="color: #888888">// Insert 100 ints:</span>
  <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">int</span> i <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; i <span style="color: #333333">!=</span> <span style="color: #0000DD; font-weight: bold">100</span>; <span style="color: #333333">++</span>i)
  {
    i_colony.insert(i);
  }

  <span style="color: #888888">// Erase half of them:</span>
  <span style="color: #008800; font-weight: bold">for</span> (plf<span style="color: #333333">::</span>colony<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">int</span><span style="color: #333333">&gt;::</span>iterator it <span style="color: #333333">=</span> i_colony.begin(); it <span style="color: #333333">!=</span> i_colony.end(); <span style="color: #333333">++</span>it)
  {
    it <span style="color: #333333">=</span> i_colony.erase(it);
  }

  <span style="color: #888888">// Total the remaining ints:</span>
  <span style="color: #333399; font-weight: bold">int</span> total <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>;

  <span style="color: #008800; font-weight: bold">for</span> (plf<span style="color: #333333">::</span>colony<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">int</span><span style="color: #333333">&gt;::</span>iterator it <span style="color: #333333">=</span> i_colony.begin(); it <span style="color: #333333">!=</span> i_colony.end(); <span style="color: #333333">++</span>it)
  {
    total <span style="color: #333333">+=</span> <span style="color: #333333">*</span>it;
  }

  std<span style="color: #333333">::</span>cout <span style="color: #333333">&lt;&lt;</span> <span style="background-color: #fff0f0">"Total: "</span> <span style="color: #333333">&lt;&lt;</span> total <span style="color: #333333">&lt;&lt;</span> std<span style="color: #333333">::</span>endl;
  std<span style="color: #333333">::</span>cin.get();
  <span style="color: #008800; font-weight: bold">return</span> <span style="color: #0000DD; font-weight: bold">0</span>;
} </code></pre>
</div>

<h4>Example demonstrating pointer stability</h4>
<code><!-- HTML generated using hilite.me --></code> 

<div
style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;">
<pre style="margin: 0; line-height: 125%"><code><span style="color: #557799">#include &lt;iostream&gt;</span>
<span style="color: #557799">#include "plf_colony.h"</span>

<span style="color: #333399; font-weight: bold">int</span> <span style="color: #0066BB; font-weight: bold">main</span>(<span style="color: #333399; font-weight: bold">int</span> argc, <span style="color: #333399; font-weight: bold">char</span> <span style="color: #333333">**</span>argv)
{
  plf<span style="color: #333333">::</span>colony<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">int</span><span style="color: #333333">&gt;</span> i_colony;
  plf<span style="color: #333333">::</span>colony<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">int</span><span style="color: #333333">&gt;::</span>iterator it;
  plf<span style="color: #333333">::</span>colony<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">int</span> <span style="color: #333333">*&gt;</span> p_colony;
  plf<span style="color: #333333">::</span>colony<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">int</span> <span style="color: #333333">*&gt;::</span>iterator p_it;

  <span style="color: #888888">// Insert 100 ints to i_colony and pointers to those ints to p_colony:</span>
  <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">int</span> i <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; i <span style="color: #333333">!=</span> <span style="color: #0000DD; font-weight: bold">100</span>; <span style="color: #333333">++</span>i)
  {
    it <span style="color: #333333">=</span> i_colony.insert(i);
    p_colony.insert(<span style="color: #333333">&amp;</span>(<span style="color: #333333">*</span>it));
  }

  <span style="color: #888888">// Erase half of the ints:</span>
  <span style="color: #008800; font-weight: bold">for</span> (it <span style="color: #333333">=</span> i_colony.begin(); it <span style="color: #333333">!=</span> i_colony.end(); <span style="color: #333333">++</span>it)
  {
    it <span style="color: #333333">=</span> i_colony.erase(it);
  }

  <span style="color: #888888">// Erase half of the int pointers:</span>
  <span style="color: #008800; font-weight: bold">for</span> (p_it <span style="color: #333333">=</span> p_colony.begin(); p_it <span style="color: #333333">!=</span> p_colony.end(); <span style="color: #333333">++</span>p_it)
  {
    p_it <span style="color: #333333">=</span> p_colony.erase(p_it);
  }

  <span style="color: #888888">// Total the remaining ints via the pointer colony (pointers will still be valid even after insertions and erasures):</span>
  <span style="color: #333399; font-weight: bold">int</span> total <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>;

  <span style="color: #008800; font-weight: bold">for</span> (p_it <span style="color: #333333">=</span> p_colony.begin(); p_it <span style="color: #333333">!=</span> p_colony.end(); <span style="color: #333333">++</span>p_it)
  {
    total <span style="color: #333333">+=</span> <span style="color: #333333">*</span>(<span style="color: #333333">*</span>p_it);
  }

  std<span style="color: #333333">::</span>cout <span style="color: #333333">&lt;&lt;</span> <span style="background-color: #fff0f0">"Total: "</span> <span style="color: #333333">&lt;&lt;</span> total <span style="color: #333333">&lt;&lt;</span> std<span style="color: #333333">::</span>endl;
  
  <span style="color: #008800; font-weight: bold">if</span> (total <span style="color: #333333">==</span> <span style="color: #0000DD; font-weight: bold">2500</span>)
  {
    std<span style="color: #333333">::</span>cout <span style="color: #333333">&lt;&lt;</span> <span style="background-color: #fff0f0">"Pointers still valid!"</span> <span style="color: #333333">&lt;&lt;</span> std<span style="color: #333333">::</span>endl;
  }
  
  std<span style="color: #333333">::</span>cin.get();
  <span style="color: #008800; font-weight: bold">return</span> <span style="color: #0000DD; font-weight: bold">0</span>;
} </code></pre>
</div>

<h4>Iterator Invalidation</h4>

<table border="1">
  <tbody>
    <tr>
      <td>All read only operations, swap, std::swap:</td>
      <td>Never</td>
    </tr>
    <tr>
      <td>clear, reinitialize, operator = </td>
      <td>Always</td>
    </tr>
    <tr>
      <td>reserve, shrink_to_fit</td>
      <td>Only if capacity is changed</td>
    </tr>
    <tr>
      <td>erase</td>
      <td>Only for the erased element</td>
    </tr>
    <tr>
      <td>insert, emplace</td>
      <td>Never</td>
    </tr>
  </tbody>
</table>

<h4>Member types</h4>

<table border="1">
  <tbody>
    <tr>
      <td><b>Member type</b></td>
      <td><b>Definition</b></td>
    </tr>
    <tr>
      <td>value_type</td>
      <td>T</td>
    </tr>
    <tr>
      <td>allocator_type</td>
      <td>Allocator</td>
    </tr>
    <tr>
      <td>size_type</td>
      <td>Allocator::size_type (pre-c++11)<br>
        std::allocator_traits&lt;Allocator&gt;::size_type (post-c++11)</td>
    </tr>
    <tr>
      <td>difference_type</td>
      <td>Allocator::difference_type (pre-c++11)<br>
        std::allocator_traits&lt;Allocator&gt;::difference_type
      (post-c++11)</td>
    </tr>
    <tr>
      <td>reference</td>
      <td>Allocator::reference (pre-c++11)<br>
        value_type &amp; (post-c++11)</td>
    </tr>
    <tr>
      <td>const_reference</td>
      <td>Allocator::const_reference (pre-c++11)<br>
        const value_type &amp; (post-c++11)</td>
    </tr>
    <tr>
      <td>pointer</td>
      <td>Allocator::pointer (pre-c++11)<br>
        value_type &amp; (post-c++11)</td>
    </tr>
    <tr>
      <td>const_pointer</td>
      <td>Allocator::const_pointer (pre-c++11)<br>
        std::allocator_traits&lt;Allocator&gt;::const_pointer (post-c++11)</td>
    </tr>
    <tr>
      <td>iterator</td>
      <td>BidirectionalIterator</td>
    </tr>
    <tr>
      <td>const_iterator</td>
      <td>Constant BidirectionalIterator</td>
    </tr>
    <tr>
      <td>reverse_iterator</td>
      <td>BidirectionalIterator</td>
    </tr>
    <tr>
      <td>const_reverse_iterator</td>
      <td>Constant BidirectionalIterator</td>
    </tr>
  </tbody>
</table>

<h3>Constructor usage examples</h3>
<ul>
  <li><code>colony&lt;T&gt; a_colony</code> 
    <p>Default constructor - default minimum group size is 8, default maximum
    group size is 65535.<br>
    Example: <code style="color: brown">plf::colony&lt;int&gt;
    int_colony;</code> </p>
  </li>
  <li><code>colony&lt;T, the_allocator&lt;T&gt; &gt; a_colony</code> 
    <p>Default constructor, but using a custom memory allocator eg. something
    other than std::allocator. Custom allocators can also be used with all the
    definitions below, of course. <br>
    Example: <code style="color: brown">plf::colony&lt;int,
    tbb::allocator&lt;int&gt; &gt; int_colony;</code> </p>
  </li>
  <li><code>colony&lt;T&gt; a_colony(const size_type minimum_group_size)</code> 
    <p>Directed constructor where the minimum group size (ie. the size of the
    first group in the colony) can be defined, for example, to be 50 elements.
    Unlike a vector these first 50 elements are not constructed - only the
    minimum group size is set. A minor performance advantage can be had by
    using this constructor feature if you know in advance roughly how many
    objects are likely to be stored in your colony - or at least the rough
    scale of storage. If that case, using this can stop many small initial
    groups being allocated. <br>
    Example: <code style="color: brown">plf::colony&lt;int&gt;
    int_colony(62);</code></p>
  </li>
  <li><code>colony&lt;T&gt; a_colony(const size_type initial_group_size, const
    size_type maximum_group_size)</code> 
    <p>Like the above this is a directed constructor - the first number sets
    the number of elements in the first group, while the second number sets the
    absolute maximum number of elements any given group may hold ie. Once a
    group reaches this size, further groups will not increase in size. This
    could be useful in a scenario where memory is at a premium and where large
    amounts of erasures are occuring. In that situation, by defining a lower
    group size you increase the likelihood of any given group becoming empty
    and hence deallocated and freed to system memory. The minimum group size
    may not be smaller than 3, and the maximum group size may not be larger
    than 65535.<br>
    Example: <code style="color: brown">plf::colony&lt;int&gt; int_colony(64,
    512);</code></p>
  </li>
  <li><code>colony&lt;T&gt; a_colony(const colony &amp;another_colony)</code> 
    <p>Copy constructor - copies all contents from another_colony, removes any
    empty (erased) element spaces. Initial group size is the total size of
    another_colony. <br>
    Example: <code style="color: brown">plf::colony&lt;int&gt;
    int_colony_2(int_colony_1);</code></p>
  </li>
  <li><code>colony&lt;T&gt; a_colony(colony &amp;&amp;another_colony)</code> 
    <p>Move constructor - moves all contents from another colony, does not
    remove any erased elements or alter any group sizes. another_colony is now
    void of contents, can be safely destructed. <br>
    Example: <code style="color: brown">plf::colony&lt;int&gt;
    int_colony_2(std::move(int_colony_1));</code></p>
  </li>
</ul>

<h3>Iterator details</h3>

<p>All iterators are bidirectional but also provide &gt;, &lt;, &gt;= and &lt;=
for convenience (for example, in for loops). Functions for iterator,
reverse_iterator, const_iterator and const_reverse_iterator follow:</p>

<p><code>operator *<br>
operator -&gt;<br>
operator ++<br>
operator --<br>
operator =<br>
operator ==<br>
operator !=<br>
operator &lt;<br>
operator &gt;<br>
operator &lt;=<br>
operator &gt;=<br>
base() (reverse_iterator and const_reverse_iterator only)</code> </p>

<p>All operators have O(1) amortised time-complexity. Originally there were +=,
-=, + and - operators, however the time complexity of these varied from O(n) to
O(1) depending on the underlying state of the colony, averaging in at O(log n).
As such they were not includable in the iterator functions (as per C++
standards). These have been transplanted to colony's advance(), next(), prev()
and distance() functions. Greater-than/lesser-than operator usage indicates
whether an iterator is higher/lower in position compared to another iterator in
the same colony (ie. closer to the end/beginning of the colony).</p>

<h3>Member functions</h3>
<ul>
  <li><code>iterator insert(const the_type &amp;element)</code> 
    <p>Inserts the element supplied to the colony, using the object's
    copy-constructor. Will insert the element into a previously erased element
    slot if one exists, otherwise will insert to back of colony. Returns
    iterator to location of inserted element. Example:</p>
    <code style="color: brown">plf::colony&lt;unsigned int&gt;
    data_colony(50);<br>
    data_colony.insert(23);</code> </li>
  <li><code>iterator insert(the_type &amp;&amp;element) <b>C++11
    only</b></code> 
    <p>Moves the element supplied to the colony, using the object's
    move-constructor. Will insert the element in a previously erased element
    slot if one exists, otherwise will insert to back of colony. Returns
    iterator to location of inserted element. Example:</p>
    <p><code style="color: brown">struct just_struct<br>
    {<br>
    &nbsp;&nbsp;unsigned int number;<br>
    &nbsp;&nbsp;std::string string1;<br>
    };<br>
    <br>
    just_struct X;<br>
    X.number = 5;<br>
    X.string1 = "Some text";<br>
    <br>
    plf::colony&lt;just_struct&gt; data_colony(50);<br>
    data_colony.insert(std::move(X));</code> </p>
  </li>
  <li><code>void insert(iterator start_iterator, iterator stop_iterator)</code> 
    <p>Inserts the contents of a colony of the same element type (eg. int,
    float, a particular class, etcetera) into the given colony. Stops inserting
    once it reaches the stop_iterator. Example:</p>
    <code style="color: brown">// Insert all contents of colony2 into
    colony1:<br>
    colony1.insert(colony2.begin(), colony2.end());</code> </li>
  <li><code>iterator emplace(Arguments ...parameters) <b>C++11 only</b></code> 
    <p>Constructs new element directly within colony. Will insert the element
    in a previously erased element slot if one exists, otherwise will insert to
    back of colony. Returns iterator to location of inserted element.
    "...parameters" are whatever parameters are required by the object's
    constructor. Example:</p>
    <p><code style="color: brown">class simple_class<br>
    {<br>
    private:<br>
    &nbsp;int number;<br>
    public:<br>
    &nbsp;simple_class(int a_number): number (a_number) {};<br>
    };<br>
    <br>
    plf::colony&lt;simple_class&gt; simple_classes;<br>
    simple_classes.emplace(45); </code> </p>
  </li>
  <li><code>iterator erase(const iterator &amp;the_iterator)</code> 
    <p>Removes the element pointed to by the supplied iterator, from the
    colony. Returns an iterator pointing to the next non-erased element in the
    colony (or to end() if no more elements are available). This must return an
    iterator because if a colony group becomes entirely empty, it will be
    removed from the colony, invalidating the existing iterator. Attempting to
    erase a previously-erased element results in undefined behaviour (this is
    checked for via an assert in debug mode). Example:</p>
    <code style="color: brown">plf::colony&lt;unsigned int&gt;
    data_colony(50);<br>
    plf::colony&lt;unsigned int&gt;::iterator an_iterator;<br>
    an_iterator = data_colony.insert(23);<br>
    an_iterator = data_colony.erase(an_iterator);</code> </li>
  <li><code>void erase(const iterator &amp;begin_iterator, const iterator
    &amp;end_iterator)</code> 
    <p>Erases all contents of a given colony from the begin_iterator to the
    element before the end_iterator. Example:</p>
    <code style="color: brown">plf::colony&lt;int&gt; iterator1 =
    colony1.begin() + 10;<br>
    plf::colony&lt;int&gt; iterator2 = colony1.begin() + 20;<br>
    colony1.erase(iterator1, iterator2);</code> </li>
  <li><code>int erase(const element_type *the_pointer)</code> 
    <p>This enables erasure via a colony element's pointer, rather than it's
    iterator. This is expected to be useful in the use-case where external
    containers are storing pointers to colony elements instead of iterators (as
    iterators have 3 times the size of an element pointer) and the program
    wants to erase the element being pointed to. This method is about 20%
    slower on average than iterator-based erasure as a lookup has to be
    performed to find the colony element's group - but still faster than all
    std:: container erasure times except std::list, which it is roughly equal
    to. Returns non-zero if element pointer was not found in any colony group.
    Attempting to erase a previously-erased element results in undefined
    behaviour (this is checked for via an assert in debug mode). Example:</p>
    <p><code style="color: brown">plf::colony&lt;a_struct&gt; data_colony();<br>
    plf::colony&lt;a_struct&gt;::iterator an_iterator;<br>
    a_struct struct_instance;<br>
    an_iterator = data_colony.insert(struct_instance);<br>
    a_struct *struct_pointer = &amp;(*an_iterator);<br>
    int success = data_colony.erase(struct_pointer);<br>
    if (success) std::cout &lt;&lt; "Erasure successful" &lt;&lt;
    std::endl;</code> </p>
  </li>
  <li><code>bool empty()</code> 
    <p>Returns a boolean indicating whether the colony is currently empty of
    elements.<br>
    Example: <code style="color: brown">if (object_colony.empty())
    return;</code></p>
  </li>
  <li><code>size_type size()</code> 
    <p>Returns total number of elements currently stored in container.<br>
    Example: <code style="color: brown">std::cout &lt;&lt; i_colony.size()
    &lt;&lt; std::endl;</code></p>
  </li>
  <li><code>size_type max_size()</code> 
    <p>Returns the maximum number of elements that the allocator can store in
    the container. This is an approximation as it does attempt to measure the
    memory overhead of the container's internal memory structures. It is not
    possible to measure the latter because a copy operation may change the
    number of groups utilized for the same amount of elements, if the maximum
    or minimum group sizes are different in the source container.<br>
    Example: <code style="color: brown">std::cout &lt;&lt; i_colony.max_size()
    &lt;&lt; std::endl;</code></p>
  </li>
  <li><code>size_type capacity()</code> 
    <p>Returns total number of elements currently able to be stored in
    container without expansion.<br>
    Example: <code style="color: brown">std::cout &lt;&lt; i_colony.capacity()
    &lt;&lt; std::endl;</code></p>
  </li>
  <li><code>void shrink_to_fit()</code>
    <p>Reduces container capacity to the amount necessary to store all currently stored elements. If the total number of elements is larger than the maximum group size, the resultant capacity will be equal to <code>((total_elements / max_group_size) + 1) * max_group_size</code> (rounding down at division). Invalidates all pointers, iterators and references to elements within the container.<br>
    Example: <code style="color: brown">i_colony.shrink_to_fit();</code></p>
  </li>
  <li><code>void reserve(unsigned short reserve_amount)</code>
    <p>Preallocates memory space sufficient to store the number of elements
    indicated by <code>reserve_amount</code>. The maximum size for this number
    is limited to the maximum group size of the colony and will be truncated if necessary. The default maximum group size is 65535 on
    the majority of platforms.<br>
    Example: <code style="color: brown">i_colony.reserve(15);</code></p>
  </li>
  <li><code>void clear()</code> 
    <p>Empties the colony and removes all elements. Deallocates all groups and
    creates a new starting group of the same size as the original starting
    group (8, unless specified otherwise by constructor or reinitialize
    call).<br>
    Example: <code style="color: brown">object_colony.clear();</code></p>
  </li>
  <li><code>void reinitialize(const size_type new_size)</code> 
    <p>Clears the colony, creates a new starting group of the size
    specified.<br>
    Example: <code
    style="color: brown">object_colony.reinitialize(1000);</code></p>
  </li>
  <li><code>void reinitialize(const size_type new_size, const size_type
    maximum_size)</code> 
    <p>Clears the colony, creates a new starting group of the size specified,
    with the maximum potential group size set to maximum_size.<br>
    Example: <code style="color: brown">object_colony.reinitialize(1000,
    100000);</code></p>
  </li>
  <li><code>void swap(colony &amp;source)</code> 
    <p>Swaps the colony's contents with that of <code>source</code>.<br>
    Example: <code
    style="color: brown">object_colony.swap(other_colony);</code></p>
  </li>
  <li><code>friend void swap(colony &amp;A, source &amp;B)</code> 
    <p>External friend function, swaps the colony A's contents with that of
    colony B (assumes both stacks have same element type).<br>
    Example: <code style="color: brown">swap(object_colony,
    other_colony);</code></p>
  </li>
  <li><code>colony &amp; operator = (const colony &amp;source)</code> 
    <p>Copy the elements from another colony to this colony, clearing this
    colony of existing elements first.<br>
    Example: <code style="color: brown">// Manually swap data_colony1 and
    data_colony2 in C++03<br>
    data_colony3 = data_colony1;<br>
    data_colony1 = data_colony2;<br>
    data_colony2 = data_colony3;</code></p>
  </li>
  <li><code>colony &amp; operator = (const colony &amp;&amp;source) <b>C++11
    only</b></code> 
    <p>Move the elements from another colony to this colony, clearing this
    colony of existing elements first. Source colony becomes invalid but can be
    safely destructed without undefined behaviour.<br>
    Example: <code style="color: brown">// Manually swap data_colony1 and
    data_colony2 in C++11<br>
    data_colony3 = std::move(data_colony1);<br>
    data_colony1 = std::move(data_colony2);<br>
    data_colony2 = std::move(data_colony3);</code></p>
  </li>
  <li><code>bool operator == (const colony &amp;source)</code> 
    <p>Compare contents of another colony to this colony. Returns a boolean as
    to whether they are equal.<br>
    Example: <code style="color: brown">if (object_colony == object_colony2)
    return;</code></p>
  </li>
  <li><code>bool operator != (const colony &amp;source)</code> 
    <p>Compare contents of another colony to this colony. Returns a boolean as
    to whether they are not equal.<br>
    Example: <code style="color: brown">if (object_colony != object_colony2)
    return;</code></p>
  </li>
  <li><code>iterator begin(), iterator end(), const_iterator cbegin(),
    const_iterator cend()</code> 
    <p>Return iterators pointing to, respectively, the first element of the
    colony and the element one-past the end of the colony (as per standard STL
    guidelines).</p>
  </li>
  <li><code>reverse_iterator rbegin(), reverse_iterator rend(),
    const_reverse_iterator cbegin(), const_reverse_iterator cend()</code> 
    <p>Return reverse iterators pointing to, respectively, the last element of
    the colony and the element one-before the first element of the colony (as
    per standard STL guidelines).</p>
  </li>
</ul>
<ul>
  <li><code>template &lt;iterator_type&gt; void advance(iterator_type iterator,
    distance_type distance)</code> 
    <p>Increments/decrements the iterator supplied by the positive or negative
    amount indicated by <i>distance</i>. Speed of incrementation will almost
    always be faster than using the ++ operator on the iterator for increments
    greater than 1. In some cases it may approximate O(1). The iterator_type
    can be an iterator, const_iterator, reverse_iterator or
    const_reverse_iterator.<br>
    Example: <code style="color: brown">colony&lt;int&gt;::iterator it =
    i_colony.begin();<br>
    i_colony.advance(it, 20); </code></p>
  </li>
  <li><code>template &lt;iterator_type&gt; iterator_type next(const
    iterator_type &amp;iterator, distance_type distance)</code> 
    <p>Creates a copy of the iterator supplied, then increments/decrements this
    iterator by the positive or negative amount indicated by
    <i>distance</i>.<br>
    Example: <code style="color: brown">colony&lt;int&gt;::iterator it =
    i_colony.next(i_colony.begin(), 20);</code></p>
  </li>
  <li><code>template &lt;iterator_type&gt; iterator_type prev(const
    iterator_type &amp;iterator, distance_type distance)</code>
    <p>Creates a copy of the iterator supplied, then decrements/increments this
    iterator by the positive or negative amount indicated by
    <i>distance</i>.<br>
    Example: <code style="color: brown">colony&lt;int&gt;::iterator it2 =
    i_colony.prev(i_colony.end(), 20);</code></p>
  </li>
  <li><code>template &lt;iterator_type&gt; difference_type distance(const
    iterator_type &amp;first, const iterator_type &amp;last)</code> 
    <p>Measures the distance between two iterators, returning the result, which
    will be negative if the second iterator supplied is before the first
    iterator supplied in terms of it's location in the colony.<br>
    Example: <code style="color: brown">colony&lt;int&gt;::iterator it =
    i_colony.next(i_colony.begin(), 20);<br>
    colony&lt;int&gt;::iterator it2 = i_colony.prev(i_colony.end(), 20);<br>
    std::cout "Distance: " i_colony.distance(it, it2) std::endl;</code></p>
  </li>
</ul>

<h2><a id="benchmarks"></a>Benchmarks</h2>

<p style="font-size: 75%"><i>Last updated 06-05-2016 v3.04</i></p>

<p>The test setup is an E8500 on an Intel motherboard, 8GB ram, running GCC 5.1
x64 as compiler. Build settings are
"-O2;-march=native;-std=c++11;-fomit-frame-pointer". Results for Visual Studio
2013 can be found <a href="colony_benchmark_msvc_results.htm">here</a>. Tests
are based on a sliding scale of number of runs vs number of elements, so a test
with only 10 elements in a container may average 100000 runs, whereas a test
with 100000 elements may only average 10 runs. This tends to give adequate
results without overly lengthening test times. I have not included results
involving 'reserve()' functions as the differences to overall insertion
performance were not adequate. The source code can be found in the <a
href="#download">downloads</a> section above.</p>

<h4>Overall tests design</h4>

<p><b>Insertion:</b> is into empty containers (with the exception of one
clearly-labeled re-insertion test toward the end), entering single elements at
a time. This matches the use case of colony, where insertion on-the-fly is
expected.<br>
<b>Erasure:</b> initially takes place in an iterative fashion for the raw
tests, erasing elements at random as we iterate through the container. This
does not fit best use case for std::deque or std::vector, which would usually
take the form of a remove_if pattern, but that pattern makes no performance
difference to colony, and the raw tests are primarily looking for good
candidates to compare versus colony. In the comparative and modification tests
vector/deque comparisons with remove_if erasures are included.<br>
<b>Iteration:</b> is straightforward iteration from the start to end of any
containers. Typically there are more runs for iteration than the other tests
due to them being a much quicker procedure, so more data delivers a more stable
average.</p>

<h3>Raw performance tests</h3>

<p>Before we begin measuring colony against equivalent containers (or modified
containers) ie. ones which do not invalidate pointers on erasure or insertion,
we need to identify which containers are good candidates for comparison based
on raw testing without regard to pointer/iteration invalidation. With that in
mind the following tests compares colony against the typical standard library
containers, and boost::segmented_tree, a current boost candidate. Tests are
carried out on the following types: (a) a 8-bit type ie. char, (b) a 32-bit
type ie. int, (c) a 64-bit type ie. double, (d) a small struct containing two
pointers and four scalar types, and (e) a large struct containing 2 pointers, 4
scalar types, a large array of ints and a small array of chars.</p>

<p>The first test measures time to insert N elements into a given container,
the second measures the time taken to erase 25% of those same elements from the
container, and the third test measures iteration performance after the second
test has taken place. Both linear and logarithmic views of each benchmark are
provided in order to better show the performance of lower element amounts.</p>

<h4>Insertion Performance</h4>

<p><i>Note: because plf::colony is an unordered container and subsequently we
are not concerned about insert order, push_front has been used with std::list
instead of push_back, in order to provide a fair performance comparison.</i></p>
<img alt="test result graph" src="tests/gcc/colony/raw/char_insertion.png">
<img alt="test result graph"
src="tests/gcc/colony/raw/char_insertion_log.png"><br>
<img alt="test result graph" src="tests/gcc/colony/raw/int_insertion.png"> <img
alt="test result graph" src="tests/gcc/colony/raw/int_insertion_log.png"><br>
<img alt="test result graph" src="tests/gcc/colony/raw/double_insertion.png">
<img alt="test result graph"
src="tests/gcc/colony/raw/double_insertion_log.png"><br>
<img alt="test result graph"
src="tests/gcc/colony/raw/small_struct_insertion.png"> <img
alt="test result graph"
src="tests/gcc/colony/raw/small_struct_insertion_log.png"><br>
<img alt="test result graph"
src="tests/gcc/colony/raw/large_struct_insertion.png"> <img
alt="test result graph"
src="tests/gcc/colony/raw/large_struct_insertion_log.png"><br>


<p>A predictable pattern for all but the large struct test is shown for
insertion:<br>
std::deque dominates insertion, with plf::colony equal after about 100
elements, but then for large structs it's performance completely eclipses
std::deque. std::vector is nearly on a par with std::deque for very small
element types with element numbers greater than a thousand, but becomes worse
and worse the larger the size of the stored type is, and the fewer number of
stored elements there are.<br>
segmented_tree is generally slightly worse than plf::colony for small scalar
types but is significantly worse for larger types - structs and classes.
std::list, std::map and std::multiset all perform poorly by contrast, but with
large structs the situation is almost reversed, with std::list and std::map
outperforming all other contendors except for plf::colony.</p>

<p>Overall, plf::colony and std::deque dominate, with segmented_tree taking
third place and std::list/std::map getting honourable mentions for large struct
performance.</p>

<h4>Erase Performance</h4>

<p>Here we forward-iterate over each container and erase 25% of all elements
randomly. Although typical tests for erasure speed tend to simply select
element indexes within a container randomly and erase those elements in a
non-linear sequence, this does not match real-world usage for game development.
Typically in game development data is processed sequentially for performance
reasons, and any elements that need to be removed/deactivated are done so
during this iteration, or subsequently in a post-iteration cull depending on
implementation. Similarly, reverse-iteration (which would enhance vector
erasure performance for example) is not common for cache performance reasons,
but since it might be used occasionally I have given some role to it: If (due
to the variability of random number generators) 25% of all elements have no
been erased by the end of the container, the test will reverse-iterate through
the container and randomly erase the remaining necessary number of elements
until that 25% has been reached:</p>
<img alt="test result graph" src="tests/gcc/colony/raw/char_erase_25.png"> <img
alt="test result graph" src="tests/gcc/colony/raw/char_erase_25_log.png"><br>
<img alt="test result graph" src="tests/gcc/colony/raw/int_erase_25.png"> <img
alt="test result graph" src="tests/gcc/colony/raw/int_erase_25_log.png"><br>
<img alt="test result graph" src="tests/gcc/colony/raw/double_erase_25.png">
<img alt="test result graph"
src="tests/gcc/colony/raw/double_erase_25_log.png"><br>
<img alt="test result graph"
src="tests/gcc/colony/raw/small_struct_erase_25.png"> <img
alt="test result graph"
src="tests/gcc/colony/raw/small_struct_erase_25_log.png"><br>
<img alt="test result graph"
src="tests/gcc/colony/raw/large_struct_erase_25.png"> <img
alt="test result graph"
src="tests/gcc/colony/raw/large_struct_erase_25_log.png"><br>


<p>Across all types, plf::colony dominates performance, with std::list coming
close behind and segmented_tree in third place. std::deque and std::vector have
predictably terrible performance, as much as 100000x worse than plf::colony and
std::list for large numbers of large types.</p>

<h4>Iteration Performance</h4>

<p>Since data is typically iterated across far more than it is erased or
inserted, iteration speed is for many programs more important than erase or
insertion performance, despite the fact that it is always factors of ten faster
than either of those two.</p>
<img alt="test result graph" src="tests/gcc/colony/raw/char_iteration.png">
<img alt="test result graph"
src="tests/gcc/colony/raw/char_iteration_log.png"><br>
<img alt="test result graph" src="tests/gcc/colony/raw/int_iteration.png"> <img
alt="test result graph" src="tests/gcc/colony/raw/int_iteration_log.png"><br>
<img alt="test result graph" src="tests/gcc/colony/raw/double_iteration.png">
<img alt="test result graph"
src="tests/gcc/colony/raw/double_iteration_log.png"><br>
<img alt="test result graph"
src="tests/gcc/colony/raw/small_struct_iteration.png"> <img
alt="test result graph"
src="tests/gcc/colony/raw/small_struct_iteration_log.png"><br>
<img alt="test result graph"
src="tests/gcc/colony/raw/large_struct_iteration.png"> <img
alt="test result graph"
src="tests/gcc/colony/raw/large_struct_iteration_log.png"><br>


<p>For under 1000 elements, std::list is about on par with both std::deque and
std::vector, both of which dominate these tests, with std::vector taking 1st
place. However the number of elements before this effect occurs on std::list
decreases according to how large the stored type is, suggesting that
performance in this case is due to some effect of the cpu cache or
implementation. Querying the GCC mailing list about this resulted in the
following response, which I believe to be accurate due to the correlation
between std::list iteration performance and type size: "I suspect that for
working sets which fit into the first-level cache of the CPU, the simpler
iterators for std::list are faster than std::deque because the additional
memory accesses in std::list are cheaper than the fairly complicated iterator
implementation in std::deque". What this suggests is that for typical programs,
where more than one data set is competing for space in the L1 or L2 caches,
std::list performance will not follow the pattern above and generally will be
poor.</p>

<p>plf::colony performs worse than segmented_tree for scalar types, except for
char, where segmented_tree fairs very poorly, and it outperforms it for
anything larger than a scalar ie. structs and classes.</p>

<h4>Raw tests Conclusion</h4>

<p>From the above data we can see that std::list is a good contendor against
plf::colony, but only in the following scenario - where (a) the amount of data
in the container is small enough to fit entirely into the cache and (b) where
that data set is the only data set being operated on by the program in
question, and in fact the computer as a whole. That being the case, std::list
is not a general contendor, but may have a place in specialised scenarios,
though probably certainly not in game development. That aside, it has the
advantage of not requiring modification to avoid invalidation of pointers on
insertion or erasure.</p>

<p>segmented_tree overall trails behind plf::colony and invalidates
pointers/iterators on both insertion and erasure, making it a non-contendor for
the areas where we might choose to use a colony ie. where pointer/iterator
stability is required and ordered insertion is not. std::deque is a contendor,
having strong insertion performance and excellent iteration performance but
poor erasure performance - however both std::deque invalidates pointers on
erasure, meaning it requires modification to be used. std::vector is a weaker
contendor, having weak insertion performance and extremely poor erasure
performance, however it's iteration performance is always the best, even if
std::deque is very close behind. std::vector invalidates pointers on both
insertion and erasure, meaning it will require a different modification
stragety to std::deque.</p>

<h3><a name="comparative_tests"></a>Comparative performance tests</h3>

<p>So to reiterate, colony is designed for scenarios where we require good
performance while guarantee'ing pointer stability for outside elements
referring to elements within the container, and where ordered insertion is
unimportant. This describes the majority of situations when building game
engines, and possibly in other highly compartmentalised and modular
environments. The only other container, based on the raw performance tests,
which approaches this goal without modification is std::list, unfortunately as
noted this is probably only useful for a few higly specialised scenarios due to
it's iteration performance being entirely dependent on fitting all data in the
CPU cache. The other two containers which may approach usability via
modification are std::deque and std::vector.</p>

<p>Because std::deque does not invalidate pointers upon insertion at the back
or front of the container (iterators however may be invalidated according to
the C++ standard), we don't have to worry about pointers being invalidated
during non-ordered insertion, meaning we can use a specific modification which
I'lll call a pointer-to-deque deque, or pointer_deque for short. In this
scenario we take our deque of elements, and construct a secondary deque
containing pointers to each element in the first deque. When we erase, we only
erase from the pointer deque, and when we iterate, we iterate over the pointer
deque and access only those elements pointed to by the pointer deque. In doing
so we reduce erase times for larger-than-scalar types, as it is computationally
cheaper to reallocate pointers than larger structs. We also avoid reallocation
during erasure for the element deque, meaning pointers and references to
elements within the deque stay valid.</p>

<p>We cannot employ the same tactic with std::vector because of the
reallocation during insertion regardless of insertion position. What we can do
however is to employ a similar tactic using indexes instead of pointers, which
we'll call an indexed_vector. Since indexes stay valid regardless of whether
the element vector reallocates, index access to the element vector will still
work after insertion. Since we never erase from the element vector, only the
index vector, the indexes also stay valid during erasure. Index access involves
an additional step computationally to reach the desired element, so is slightly
slower during iteration than a pointer vector, but has the same advantages
during erasure. In addition outside data refering to elements within the
indexed_vector must use indexes instead of pointers to refer to the elements.
This complicates implementation as the outside data source must know which
container it is indexing, whereas a pointer approach can ignore this and simply
point to an element.</p>

<p>We will also compare the same two container modifications above using a
<i>remove_if</i> erasure pattern, adding an additional boolean field to
indicate erasure to the original stored struct type, and utilizing two passes -
the first to randomly flag elements as being ready for erasure via the boolean
field, the second using the <i>remove_if</i> pattern. This matches some use
cases in game engines where erasures are 'saved up' until the end of a given
frame, then processes. A third modified approach, which we'll call a
deque_bool, is a very common approach in a lot of game engines - a bool or
similar type is added to the original struct or class, and this type is tested
against to see whether or not the object is 'active' (true) - if inactive
(false), it is skipped over. This is somewhat similar to what a colony does,
but without the separate jump-counting skipfield which increases iteration
speed and removes the branching decisions. Again, for the purposes of this test
this is not possible with a vector of elements, as insertion would cause
invalidation of pointers to the elements.</p>

<p>Since neither the indexed_vector nor the pointer_deque will have erasure
time benefits for small scalar types, and because game development is
predominantly concerned with storage of larger-than-scalar types, we will only
test using small structs, for simplicity's sake. In addition, we will test 4
levels of erasure: 0% of all elements, 25% of all elements, 50% of all
elements, and 75% of all elements. And finally, we will test the performance of
the 75%-erased containers after re-inserting 25% of all elements back into each
container, to compare how the different models perform after reinsertion.</p>

<h4>Insertion</h4>
<img alt="test result graph" src="tests/gcc/colony/comparitive/insertion.png">
<img alt="test result graph"
src="tests/gcc/colony/comparitive/insertion_log.png"> 

<p>Here a deque_bool and plf::colony are more-or-less on a par with each other,
with both pointer_deque modifications slightly behind and std::list and
indexed_vector modifications performing poorly by comparison.</p>

<h4>Erasure</h4>

<h5>Erasing 25%</h5>
<img alt="test result graph" src="tests/gcc/colony/comparitive/erase_25.png">
<img alt="test result graph"
src="tests/gcc/colony/comparitive/erase_25_log.png"> 

<h5>Erasing 50%</h5>
<img alt="test result graph" src="tests/gcc/colony/comparitive/erase_50.png">
<img alt="test result graph"
src="tests/gcc/colony/comparitive/erase_50_log.png"> 

<h5>Erasing 75%</h5>
<img alt="test result graph" src="tests/gcc/colony/comparitive/erase_75.png">
<img alt="test result graph"
src="tests/gcc/colony/comparitive/erase_75_log.png"> 

<p>Here the gap consistently widens between the candidates as erasure
percentage increases, with deque_bool, plf::colony and std::list being very
close to each other in 1st, 2nd and 3rd place respectively. pointer_deque and
indexed_vector have much worse performance once the number of elements climbs
above 200, 1 factor of ten above the other candidates at 2000 elements and
almost 3 factors of ten above the other candidates at 100000 elements.
pointer_deque_remove_if and indexed_vector_remove_if perform mostly the same as
colony, eclipsing colony slightly for large amounts of erasures.</p>

<h4>Iteration</h4>

<h5>Prior to erasures</h5>
<img alt="test result graph"
src="tests/gcc/colony/comparitive/iteration_0.png"> <img
alt="test result graph" src="tests/gcc/colony/comparitive/iteration_0_log.png"> 

<p>Here std::list is more-or-less equal to all four indexed_vector and
pointer_deque modifications for under 500 elements, then just as in the
previous tests, once less of the data fits in the cache entirely it's
performance diminishes rapidly. plf::colony and deque_bool trail behind the
other contendors.</p>

<h5>After erasing 25% of all elements</h5>
<img alt="test result graph"
src="tests/gcc/colony/comparitive/iteration_25.png"> <img
alt="test result graph"
src="tests/gcc/colony/comparitive/iteration_25_log.png"> 

<p>Now we begin to see the effect of the jump-counting skipfield. std::list
does the same thing as before, but with only a quarter of the elements erased,
deque_bool's performance drops substantially and becomes worse than std::list.
plf::colony however shows only slightly worse results than pointer_deque and
indexed_vector after ~500 total elements.</p>

<h5>After erasing 50% of all elements</h5>
<img alt="test result graph"
src="tests/gcc/colony/comparitive/iteration_50.png"> <img
alt="test result graph"
src="tests/gcc/colony/comparitive/iteration_50_log.png"> 

<p>At this point the poor iteration performance of deque_bool becomes much more
apparent.</p>

<h5>After erasing 75% of all elements</h5>
<img alt="test result graph"
src="tests/gcc/colony/comparitive/iteration_75.png"> <img
alt="test result graph"
src="tests/gcc/colony/comparitive/iteration_75_log.png"> 

<p>At this point we can see that deque_bool overall performs worse than any
other contendor. Other than that it is a continuation of previously established
trends.</p>

<p>Summary: The overall pattern shows that pointer_deque and indexed_vector
modifications dominate performance with plf::colony quite close behind,
std::list performing typically and deque_bool being entirely inadequate once
erasures have occurred. The additional boolean field involved in the
<i>erasure_if</i> modifications does not appear to have an effect on
performance.</p>

<h4>Post-reinsertion iteration</h4>

<p>At this point we take the containers after the last test, at 75% erasure,
and re-insert 25% of the original number of elements, and subsequently test
iteration performance to see how reinsertion affects each container.</p>
<img alt="test result graph"
src="tests/gcc/colony/comparitive/post_insertion_iteration.png"> <img
alt="test result graph"
src="tests/gcc/colony/comparitive/post_insertion_iteration_log.png"> 

<p>While plf::colony closes the gap with pointer_deque and indexed_vector
modifications, again to become roughly similar to the post-50%-erasure
iteration test, deque_bool grows worse again. This is due to the element
location recycling that is utilized in plf::colony, as opposed to deque_bool
which has no such mechanism.</p>

<h4>Scenario testing - low modification</h4>

<p>In this test we take a container, and iterate over it for 3600 cycles,
randomly erasing approximately 1 element every 120 cycles, and randomly
inserting 1 element every 120 cycles. These numbers do not correspond to the
number of elements in the container, in other words, the same number of
elements gets removed/inserted for a 10-element container as it does for a
80000-element container. By doing so we simulate a seldom-modified container (2
modifications every 2 seconds) being used by a program for 1 minute where each
cycle represents a frame, and where there are 60 frames per second. By doing so
we play off the different performance aspects of each container to approximate
an overall conclusion. Because of std::list's limitation as per the CPU cache
and competing with other potential data as mentioned earlier, and the
unlikelihood of real-world usability as a result, we've discluded it from the
tests.</p>
<img alt="test result graph"
src="tests/gcc/colony/general_use/general_use_low_modification.png"> <img
alt="test result graph"
src="tests/gcc/colony/general_use/general_use_low_modification_log.png"> 

<p>We can see pointer_deque winning out here, followed closely by plf::colony
and indexed_vector tailing far behind. Both the <i>remove_if</i> modifications
fall in the middle, with the overhead of the additional pass obviously forming
a performance detriment for pointer_deque, and indexed_vector performing better
than indexed_vector_remove_if until around 700 elements.</p>

<h4>Scenario testing - high modification</h4>

<p>The same as the previous test, except in this test we perform 2 erasures at
random every cycle as well as 2 insertions ie. 4 modifications per frame.</p>
<img alt="test result graph"
src="tests/gcc/colony/general_use/general_use_high_modification.png"> <img
alt="test result graph"
src="tests/gcc/colony/general_use/general_use_high_modification_log.png"> 

<p>Here the results are much the same but with the increased number of
modifications per frame, we see plf::colony starting to edge out pointer_deque
in terms of overall performance.</p>

<h4>Scenario testing - Very high modification</h4>

<p>In this test we change the pattern, making the number of elements
removed/inserted a percentage of the overall size of the container. In this
case we randomly erase and insert around 10% of the container size per
frame.</p>
<img alt="test result graph"
src="tests/gcc/colony/general_use/general_use_very_high_modification.png"> <img
alt="test result graph"
src="tests/gcc/colony/general_use/general_use_very_high_modification_log.png"> 

<p>As could be expected, with the much higher number of erasures the
standard-erasure pointer_deque and indexed_vector fall far behind after
approximately 200 elements (though effects are still noticable at 100
elements). The <i>remove_if</i> variants perform much better, but colony
overall dominates performance.</p>

<h4>Overall conclusion</h4>

<p>We can legitimately say that if there is no competition for the CPU cache
ie. if the container in question is the only container being iterated over by
your program, then provided that your amount of data is small and will fit
entirely within the CPU cache, std::list is probably the best solution where we
(a) need adequate performance and (b) cannot have pointer/iterator invalidation
and (c) don't require ordered insertion. However this is a very small, unlikely
and specialised scenario - in the bulk of scenarios std::list should not be
used where pointer stability is required.</p>

<p>Using a bool or similar type to indicate erasure in a container (as
represented in this case by deque_bool) is always a poor choice by comparison
with the other options available, which becomes much more apparent as more and
more erasures occur, and this approach should not be used. Nor does separating
the skipfield into a separate block of memory repair the situation, as without
the jump-counting skipfield, runs of erasures tend to slow iteration speed. To
see a graph of the relative performance of plf::colony using a boolean field
instead of a jump-counting skipfield, vs a regular colony, a deque_bool and a
deque using, as an alternative, a boolean field separate to the data itself,
click <a href="skipfield_comparison.htm">here</a>.</p>

<p>pointer_deque and indexed_vector approaches both have strengths in terms of
iteration performance but their erasure performances are poor for anything
greater than 200 elements, so these two facets have to be traded off against
each other to determine overall performance. Their <i>remove_if</i> variants
are of course faster for higher numbers of erasures, but slower for small
numbers of erasures, so there's an inflexibility to either approach if one
wants optimal performance. What the use-case testing shows is that once this
and the insertion times are taken into account, the differences between these
approaches and plf::colony are minimal for lowered numbers of container
insertions/erasures, with pointer_deque having a slight lead in the case of an
efficient implementation (which GCC's implementation definitely is). Where high
numbers of erasures and insertions are involved, we can see plf::colony has
superior overall performance. In addition, while std::deque and std::vector's
erasure performance varies significantly based on the size of data and where
the element being erased is within that data, plf::colony's is predictable and
much faster, making it safer for low-latency environments.</p>

<p>plf::colony has an additional advantage which indexed_vector and
pointer_deque do not have - it reuses and releases erased element memory space.
When you erase from a indexed_vector/pointer_deque they don't release the
memory space to the OS, nor do they reuse the memory space for subsequent
insertions - meaning that with a high level of modification both containers are
perpetually expanding and never shrinking. Because gaming often occurs on
platforms with significant memory constraints this can be less-than-desirable.
And although one <i>can</i> implement a stack-based solution for recycling
erased element locations for either of these approaches based on a similar
technique to what is done in plf::colony, any reinsertions would come at a
cost, as adding the reference back into the vector of element indexes, or deque
of element pointers, would require an ordered insertion operation which results
in reallocation of subsequent pointers/indexes, meaning the insertion cost
becomes higher yet again.</p>

<p>For these reasons the overall recommendation is to use plf::colony for all
situations where (a) memory space is at a premium, (b) ordered insertion
doesn't matter, (c) maintaining valid pointers to container elements is
desirable and (d) insertions/erasures are occurring during operation. If
erasures and reinsertions are infrequent and memory is not at a premium then
you will be better off with a pointer_deque or indexed_vector approach.</p>

<p>plf::colony:<br>
<font style="color: green">Advantages: Fastest insertion and erase performance
except for deque_bool. Iteration performance very close to pointer_deque and
indexed_vector. Recycles or releases erased element memory locations. Best
overall performance where the ratio of insertions/erasures to iteration is
high. Insertion, erasure and iteration are all O(1) operations.</font><br>
<font style="color: red">Disadvantages: Could be slower overall than
pointer_deque or indexed_vector approaches for situations where memory
expansion is not an issue, or where erasure and reinsertion are
infrequent.</font> </p>

<p>pointer_deque:<br>
<font style="color: green">Advantages: Best overall performance where the ratio
of insertions/erasures to iterations is low. A <i>remove_if</i> approach to
erasure can improve erasure times on large numbers of per-frame
erasures.</font><br>
<font style="color: red">Disadvantages: std::deque implementation structure is
compiler-dependent, so the above advantage will not apply generically
across-compilers. Will not release erased element locations to OS, or reuse
them. Slower erasure performance, so if erasure is very frequent, may be very
slow. Erasure time is less predictable and a detriment to latency-critical
programming.</font> </p>

<p>indexed_vector:<br>
<font style="color: green">Advantages: Almost as fast as pointer_deque
approach. Implementations do not vary so much from compiler to compiler,
meaning that this approach is more likely to yield benefits generically
compared to deque implementations.</font><br>
<font style="color: red">Disadvantages: Slower than pointer_deque approach, at
least under GCC. Approach requires any outside structures referring to it's
elements to use indexes instead of pointers, which complicates implementation,
as the structure must also know the container it is referring to. Will not
release erased element locations to OS, or reuse them. Slower erasure
performance than pointer_deque under GCC, so if erasure is very frequent, may
be extremely slow. A <i>remove_if</i> erasure pattern significantly improves
performance for large numbers of erasures but performs worse with low numbers,
and overall is worse than plf::colony performance. This erasure cost may be
reduced by using smaller datatypes for indexes, for example an unsigned short
when it is known that the number of elements will not exceed 65535 - hence
reducing the amount of data needing to be reallocated upon erasures. Erasure
time is less predictable and a detriment to latency-critical
programming.</font> </p>

<h2><a id="faq"></a>Frequently Asked Questions</h2>
<ol>
  <li><h4>TLDR, what is a colony?</h4>
    <p>A combination of a linked-list of increasingly-large memory blocks with
    metadata, combined with a jump-counting skipfield, combined with an
    erased-element memory-location stack for later reinsertions, resulting in a
    std::-styled C++ template data container with positive performance
    characteristics while maintaining pointer stability to container
    elements.</p>
  </li>
  <li><h4>Where is it worth using in place of other std:: containers?</h4>
    <p>It is most worthwhile, for performance reasons, in situations where the
    order of container elements is not important, and:</p>
    <ol type="a">
      <li>Pointers and iterators which point to container elements must stay
        valid regardless of container insertions and erasures,<br>
        <br>
        <b>and/or</b><br>
      </li>
      <li>Insertions and erasures to the container will be occuring in realtime
        ie. in performance-critical code.</li>
    </ol>
    <p>Under these circumstances a colony will generally out-perform other
    std:: containers. In addition, because it never invalidates pointer or
    iterator references to container elements (except when the element being
    referred to has been previously erased) it can make many programming tasks
    involving inter-relating structures in an object-oriented or modular
    environment much faster, and can be considered in those circumstances.</p>
  </li>
  <li><h4>What are some examples of situations where a colony might improve
    performance?</h4>
    <p>Some ideal situations to use a colony: quadtree, persistent octtree,
    general game entities or destructible-objects in a video game, anywhere
    where objects are being created and destroyed continuously. Also, anywhere
    where a vector of pointers to dynamically-allocated objects or a std::list
    would typically end up being used in order to preserve object
    references.</p>
  </li>
  <li><h4>What are the time complexities for general operations?</h4>
    <p>Insertion: O(1) amortized<br>
    Erase: O(1) amortized<br>
    std::find: O(n)<br>
    <br>
    Iterator operations:<br>
    ++ and -- : O(1) amortized<br>
    begin()/end(): O(1)<br>
    advance/next/prev: between O(1) and O(n), depending on current location,
    end location and state of colony. Average O(log N).</p>
  </li>
  <li><h4>Is it similar to a deque?</h4>
    <p>A deque is fairly dissimilar to a colony. A deque is a double-ended
    queue, which requires a bit of a different internal framework. It typically
    uses a vector of memory blocks, whereas a colony uses a linked list -
    essentially. They have no comparable performance characteristics except for
    insertion (on a decent deque implementation). Deque element erasure
    performance varies quite wildly depending on the compiler compared to
    std::vector, and it does not free unused memory blocks to the OS once they
    are empty, unlike a colony. In addition a deque invalidates references to
    subsequent container elements when erasing elements, which a colony does
    not.</p>
  </li>
  <li><h4>What are the thread-safe guarantees?</h4>
    <p>Unlike a std::vector, a colony can be read from and written to at the
    same time, however it cannot be iterated over and written to at the same
    time. If we look at a std::vector's threadsafe matrix, to see which basic
    operations can occur at the same time, it reads as follows (please note
    push_back() is the same as insertion in this regard):</p>

    <table border="1" cellspacing="3">
      <tbody>
        <tr>
          <td>std::vector</td>
          <td>Insertion</td>
          <td>Erasure</td>
          <td>Iteration</td>
          <td>Read</td>
        </tr>
        <tr>
          <td>Insertion</td>
          <td>No</td>
          <td>No</td>
          <td>No</td>
          <td>No</td>
        </tr>
        <tr>
          <td>Erasure</td>
          <td>No</td>
          <td>No</td>
          <td>No</td>
          <td>No</td>
        </tr>
        <tr>
          <td>Iteration</td>
          <td>No</td>
          <td>No</td>
          <td>Yes</td>
          <td>Yes</td>
        </tr>
        <tr>
          <td>Read</td>
          <td>No</td>
          <td>No</td>
          <td>Yes</td>
          <td>Yes</td>
        </tr>
      </tbody>
    </table>
    <p>In other words, multiple reads and iterations over iterators can happen
    simultaneously, but the invalidation caused by insertion/push_back and
    erasure means those operations cannot occur at the same time as anything
    else.</p>
    <p>Colony on the other hand does not invalidate pointers/iterators to
    non-erased elements during insertion and erasure, resulting in the
    following matrix:</p>

    <table border="1" cellspacing="3">
      <tbody>
        <tr>
          <td>plf::colony</td>
          <td>Insertion</td>
          <td>Erasure</td>
          <td>Iteration</td>
          <td>Read</td>
        </tr>
        <tr>
          <td>Insertion</td>
          <td>No</td>
          <td>No</td>
          <td>No</td>
          <td>Yes</td>
        </tr>
        <tr>
          <td>Erasure</td>
          <td>No</td>
          <td>No</td>
          <td>No</td>
          <td>Mostly</td>
        </tr>
        <tr>
          <td>Iteration</td>
          <td>No</td>
          <td>No</td>
          <td>Yes</td>
          <td>Yes</td>
        </tr>
        <tr>
          <td>Read</td>
          <td>Yes</td>
          <td>Mostly</td>
          <td>Yes</td>
          <td>Yes</td>
        </tr>
      </tbody>
    </table>
    <p>In other words, reads may occur at the same time as insertions and
    erasures (provided that the element being erased is not the element being
    read), multiple reads and iterations may occur at the same time, but
    iterations may not occur at the same time as an erasure or insertion, as
    either of these may change the state of the skipfield which's being
    iterated over. Erasures will not invalidate iterators unless the iterator
    points to the erased element.</p>
    <p></p>
    <p>So, colony is inherently more threadsafe than a std::vector, but still
    has some areas which would require mutexes or atomics to navigate in a
    multithreaded environment.</p>
  </li>
  <li><h4>Any "gotcha"'s to watch out for?</h4>
    <p>Only a few:</p>
    <ol type="a">
      <li>"insert" placement can be at the back, front, or frankly anywhere in
        the container, depending on what's been erased previously and where it
        was. Insertion is essentially random unless no erasures have been made
        prior, or an equal number of erasures and insertions have been made
        prio.</li>
      <li><code>plf::colony&lt;int&gt; a_colony(500);</code> does not mean the
        same thing as <code>std::vector&lt;int&gt; a_vector(500);</code>. A
        vector inserts 500 elements using the type's default constructor when
        "(500)" is specified, for colony this does not allocate any memory, it
        just specifies the minimum number of elements per memory block (default
        minimum is 8).<br>
        It can be combined with a maximum-block-size specifier as per the faq
        entry below.</li>
      <li>Once an element has been erased, any iterator or pointer pointing to
        that element is no longer valid. This is the same as vector and other
        std:: container rules, but not the same as an array. In the case of
        colony, the memory block the iterator pointed to may no longer exist,
        because, if it were the final remaining element in the memory block,
        the group containing the memory block will have been removed from the
        colony chain. Erasure of the specific element is the only way that
        iterators and pointers to a colony element can become invalidated.</li>
    </ol>
  </li>
  <li><h4>Any special-case uses?</h4>
    <p>In the special case where many, many elements are being continually
    erased/inserted in realtime, you might want to experiment with limiting the
    size of your internal memory groups in the constructor. The form of this is
    as follows:<br>
    <code>plf::vector&lt;object&gt; a_vector(500, 5000);</code><br>
    where the first number is the minimum size of the internal memory groups
    and the second is the maximum size. Note these can be the same size,
    resulting in an unchanging group size for the lifetime of the colony
    (unless reinitialize or operator = is called).<br>
    One reason to do this is that it is slightly slower to pop an element
    location off the internal memory position recycling stack, than it is to
    insert a new element to the end of the colony (the default behaviour when
    there are no previously-erased elements). If there are any erased elements
    in the colony, the colony will recycle those memory locations, unless the
    entire group is empty, at which point it is freed to memory. So if a group
    size is large and many, many erasures occur but the group is not completely
    emptied, (a) the number of erased element locations in the recycling stack
    could get very large, resulting in a detriment to performance and (b)
    iteration performance will suffer. In that scenario you may want to run a
    benchmark limiting the minimum/maximum sizes of the groups, and tune it
    until you find optimal usage.</p>
  </li>
  <li><h4>What is colony's Abstract Data Type (ADT)?</h4>
    <p>While I am happy to be proven wrong I suspect colony is it's own
    abstract data type. Some have suggested it is most similar to a multiset or
    bag, which is probably true, but from my perspective a bag or multiset
    utilizes key values. Colony does not utilize key values, is searchable and
    sortable, but does not give the sort of functionality one would find in a
    bag (for example counting the number of times a specific value occurs).
    Others have suggested a deque, but actually there are three necessary
    aspects to colony which make it function as it does, and which define any
    implementation:</p>
    <ol>
      <li>A multiple-memory-block based allocation pattern which allows for the
        removal of memory blocks when they become empty of elements.</li>
      <li>A skipfield to indicate erasures instead of reallocating elements,
        the iteration of which should typically not necessitate the use of
        branching code.</li>
      <li>A stack of erased element locations to allow for reuse of erased
        element memory space upon subsequent insertion.</li>
    </ol>
    <p>In the case of my particular colony implementation I utilize a <a
    href="chained_group_allocation_pattern.htm">chained-group memory allocation
    pattern</a> because it appears to have better performance than the
    alternatives, arguably though this could be any multiple-memory-block
    allocation strategy. For the skipfield I utilize the <a
    href="http://www.mediafire.com/download/qpy18jp4jbli7jc/the_jump_counting_skipfield_pattern.pdf">jump-counting
    skipfield</a> but if a more efficient skipfield implementation were
    available for a given platform, that could be used. While it is preferable
    that any skipfield used not utilize branching code - as a common boolean
    skipfield does - because of the performance detriment caused by this, it is
    possible there could be a computer architecture where the cost of branching
    is much lower. And for the stack I am using <a
    href="stack.htm">plf::stack</a> because according to benchmarks it is more
    efficient than the std:: alternatives. But again, if a more efficient
    alternative were found it could be used instead.</p>
    <p>If we look at a deque, the only aspect out of those three that it
    shares, is (1) - utilizing a multiple-memory-block allocation pattern.
    Which isn't a strong association. If we look at a multiset, an unordered
    one could be implemented on top of a colony utilizing an additional hash
    table, and it would be more efficient than the current multiset
    implementations as shown in the GCC and MSVC benchmarks. But the necessity
    to add something to make it a multiset, ie. to take and store key values,
    means colony is probably not a multiset, and probably it's own abstract
    data type.</p>
  </li>
  <li><h4>Exception Guarantees?</h4>
    <p>For both colony and stack all operations which allocate memory have strong exception guarantees
    and will roll back if an exception occurs, except for operator = which has
    a basic exception guarantee (see below). For colony, iterators are bounded by
    asserts in debug mode, but unbounded in release mode, so it is possible for
    an incorrect use of an iterator (iterating past end(), for example) to
    trigger an out-of-bounds memory exception. These are the only two areas
    where exceptions can occur.</p>
    <p>Similarly with plf::stack, top() and pop() operations are assert-checked against stack emptiness in debug mode, but performing these functions on an empty stack in release mode results in undefined behaviour.</p>
    The reason why operator = (for both colony and stack) only has a basic
    guarantee is they do not utilize the copy-swap idiom, as the copy-swap
    idiom significantly increases the chance of any exception occuring - this
    is because the most common way an exception tends to occur during a copy
    operation is due to a lack of memory space, and the copy-swap idiom doubles
    the memory requirement for a copy operation by constructing the copy before
    destructing the original data. This is doubly innappropriate in game development, which colony has been initially for, where memory constraints are often critical and the runtime lag from memory spikes can cause detrimental game performance. So in the case of colony and plf::stack, if a non-memory-allocation-based exception occurs during copy, the = operators will have already destructed
    their data, so the containers will be empty and cannot roll back - hence they have a basic guarantee, not a
    strong guarantee.</p>
  </li>
</ol>
<br>
<br>


<h2><a id="version"></a>Version history</h2>
<ul>
  <li>2016-06-11: v3.19 - Minor bugfix to plf::stack.</li>
  <li>2016-06-9: v3.18 - Corrections to colony and stack C++11 typedefs. Some code
    tidyup. Minor code corrections. Simplified reserve() and shrink_to_fit() functions. Added trim_trailing_groups() function to stack. Minor performance improvements.</li>
  <li>2016-05-31: v3.16 - Corrections to colony and stack reserve(). Some code
    tidyup. Correction to test suite.</li>
  <li>2016-05-30: v3.15 - Colony and stack are now compliant with C++11 and
    C++14 <a
    href="http://en.cppreference.com/w/cpp/concept/Container">container</a>
    concepts. Vectorized some erasure and insertion operations resulting in
    better overall performance in some scenarios. Corrected edge case in
    reverse iteration operator ++. All iterators now bounded by asserts in
    debug mode. Correction to capacity functions.</li>
  <li>2016-05-26: v3.14 - Added swap (std::swap worked fine without it, mainly
    required for standards compliance, also is exception-safe) and max_size()
    functions to stack and colony.</li>
  <li>2016-05-24: v3.13 - erase(element_pointer) added to colony. This enables
    erasure via a colony element's pointer, rather than it's iterator. Slightly
    slower than iterator-based erasure as a lookup has to be done for the
    colony element's group. Update to test suite.</li>
  <li>2016-05-19: v3.11 - Fix for colony shrink_to_fit(), added special case to
    stack copy constructor for when source size &gt; max_group_size, colony and
    stack constructors now explicit. Update to test suite.</li>
  <li>2016-05-12: v3.10 - Both stack and colony no longer preallocate upon
    construction, only upon first insertion. Minor assert bugfix in colony.
    shrink_to_fit(), reserve() and capacity() functions added to both classes.
    Some code cleanup, corrections for C++03 and minor optimizations.</li>
  <li>2016-04-28: v3.05 - Removal of compiler-specific iteration code,
    resulting in 8% speedup for larger-than-scalar type iteration, 6% slowdown
    for scalar-type iteration, under GCC x64. MSVC unaffected by change.
    Addition of benchmark suite. Correction to plf_nanotimer under
  linux/bsd.</li>
  <li>2016-04-16: v3.04 - Corrections to reinitialize asserts. Added
    bound-checking asserts to advance/next/prev implementations.</li>
  <li>2016-03-26: v3.03 - Correction to operator = on colony. Replaced
    SDL2/SDL_Timer in benchmarks with plf_nanotimer, a cross-platform
    ~nanosecond-precision timer. Correction to end() and begin() overloads -
    internal begin/end iterator could previously be altered by user activity,
    in some cases. Correction to .next functions.</li>
  <li>2016-03-24: v3.02 - Small performance improvements. Fix for demo for
    regular SDL2 usage. Duplication of macros from plf_stack.h to plf_colony.h
    to fix issue when plf_stack.h is also used within project separately from
    plf_colony.h. </li>
  <li>2016-02-23: v3.01 - Colony now uses a <a
    href="http://www.mediafire.com/download/qpy18jp4jbli7jc/the_jump_counting_skipfield_pattern.pdf">jump-counting
    skipfield</a> instead of a boolean field, which mitigates worst-case
    scenario performance by factors of ten. Iterators now bidirectional (but
    include &gt; &lt; &gt;= and &lt;= operators) instead of random-access, and
    compliant with C++-specification's time-complexity requirements (all
    operations O(1) amortised). +=, -=, - and + iterator operators relegated to
    advance, distance, next and prev functions under colony. There is greater
    compliance with allocators. Group size now limited to 65535 max for colony,
    to decrease memory wastage and improve skipfield performance. Various
    bugfixes and corrections. plf::stack storage limit no longer 32-bit uint
    max (relies on allocator to supply correct size_type). Added worst-case and
    best-case scenario tests to colony benchmark, and added std::stack
    comparison to plf::stack benchmark. Benchmarks yet to be updated in
  docs.</li>
  <li>2015-11-20: v2.34 - Correction to clear() and reinitialize()
  functions.</li>
  <li>2015-11-17: v2.33 - Minor bugfix for GCC versions &lt; 5.</li>
  <li>2015-11-2: v2.32 - Minor bugfix for non-trivial pointers and non-trivial
    stack contents.</li>
  <li>2015-10-31: v2.31 - Allocators which supply non-trivial pointers are now
    supported. Large macros removed. Some code cleanup and minor performance
    gain.</li>
  <li>2015-10-10: v2.26 - 'back()' in plf::stack changed to 'top()' to better
    reflect std:: library stack implementation function titles. Added standard
    container typedefs to colony and stack. Colony iterators now return
    element_allocator::pointer and element_allocator::reference instead of
    element_type * and element_type &amp;. Some minor code cleanup.</li>
  <li>2015-10-6: v2.24 - Bugfix for C++03 with x64 compilers. Minor
    corrections, performance improvements for C++03 compilers.</li>
  <li>2015-10-4: v2.21 - Improved gcc x64 iteration. std::find now working with
    reverse_iterator. reverse_iterator function corrections, performance
    improvements. Hintless allocators under C++11 now supported. Allocation now
    uses allocator_traits under C++11.</li>
  <li>2015-9-30: v2.13 - Fixed performance regression with small primitive
    types and MS VCC. Small bugfixes.</li>
  <li>2015-9-28: v2.12 - Added const_iterator, const_reverse_iterator, .cbegin,
    .cend, .crbegin, .crend. Some small bugfixes.</li>
  <li>2015-9-27: v2.00 - Larger performance improvements, particularly for
    small primitive type storage. Corrections to exception handling and EBCO.
    ".insert" replaces ".add" (realised there is precedence for
    non-position-based insert via unordered_map/unordered_set). Added postfix
    iterator increment and decrement. Zero-argument ".add()" and ".push()"
    function overloads removed (same thing achievable with
    "colony.insert(the_type());" and "stack.push(the_type());". Many bugfixes
    and general code cleanup.</li>
  <li>2015-9-15: v1.79 - Empty base class allocator optimisations and smaller
    optimisation.</li>
  <li>2015-9-1: v1.77 - Some small bugfixes.</li>
  <li>2015-8-30: v1.76 - Now exception-safe. Also fixed C++03 regression
  bug.</li>
  <li>2015-8-22: v1.75 - Iterators more compliant and now work with std::find
    and should work with other std:: algorithm functions. Native find functions
    removed. (iterator - iterator) and (iterator + iterator) support added
    (relatively useless to end-users, but required by some std::
  algorithms).</li>
  <li>2015-8-15: v1.73 - Correction to noexcept/nothrow use under some
    non-c++11 compilers. Some rvalue functions corrected.</li>
  <li>2015-8-3: v1.72 - Added noexcept to more functions.</li>
  <li>2015-7-20: v1.71 - Small correction to demo, changed a data member name
    in demo to remove conflict in MSVC 2015.</li>
  <li>2015-7-13: v1.70 - Added deque comparisons to performance tests - this
    was necessary because many people were making comparisons between colonies
    and deques, without understanding what a deque is and how it
  performs...</li>
  <li>2015-6-21: v1.69 - Code tidy-up.</li>
  <li>2015-6-16: v1.67 - Correction to VS2013/VS2010 support: move semantics
    and other C++11 facets enabled for MS compilers. Support for VS2012, VS2015
    and later added. Performance bottleneck in destructors in debug mode fixed.
    General cleanup. Some microoptimisations. Macros now better named to avoid
    conflicts.</li>
  <li>2015-5-30: v1.60 - Correction to add function, microoptimizations.</li>
  <li>2015-5-29: v1.53 - Performance improvement. Corrected move constructor
    and reverse_iterator function semantics.</li>
  <li>2015-5-28: v1.52 - Small correction.</li>
  <li>2015-5-26: v1.51 - Small performance improvement. In demo, including
    SDL.h caused some weird behaviour with timer when used, changed to
    SDL_timer.h. Benchmarks to be updated.</li>
  <li>2015-5-25: v1.50 - Microoptimizations, small improvements, fixed crash in
    demo where memory would overflow when compiled to x86 without LAA.</li>
  <li>2015-5-21: v1.43 - Minor performance improvements for release mode,
    larger improvements for debug mode.</li>
  <li>2015-5-16: v1.42 - Some demo corrections.</li>
  <li>2015-5-16: v1.41 - Fixed demo on pre-C++11 compilers. Minor fixes in code
    and corrections in tests. Performance improvements.</li>
  <li>2015-5-11: v1.40 - Improved iterator ++ speed and Add speed, added
    real-world OO performance tests to demo. Added max group-size tuning (max
    number of elements per group).</li>
  <li>2015-5-6: v1.34 - Improved iterator ++ speed under VC2010 and GCC
  x64.</li>
  <li>2015-5-5: v1.33 - Improved erase, and some small performance tweaks.</li>
  <li>2015-5-4: v1.32 - Minor fixes.</li>
  <li>2015-5-3: v1.31 - Resolved all current known edge-case crashes. Improved
    stack pop performance.</li>
  <li>2015-4-26: v1.20 - Found and resolved several edge-case bugs. Improved +,
    -, += and -= iterator operator performance tremendously.</li>
  <li>2015-4-18: v1.10 - Allocators fully supported now. Improved performance.
    Some bugfixes. Added std::iterator trait to iterator. Added large struct
    tests to demo. Improved realism of array tests.</li>
  <li>2015-4-13: v1.00 - Allocators now largely supported (some work to do).
    Erasure bug fixed. First proper release.</li>
  <li>2015-4-9: v0.983 - Updated demo to be more realistic for array usage and
    to run all tests sequentially.</li>
  <li>2015-4-6: v0.982 - Bugfixes, speedup, added find functions.</li>
  <li>2015-4-2: v0.98 - First release</li>
</ul>

<p><a id="contact"></a>Contact: <img alt="footer" src="footer.gif"><br>
plf:: library and this page Copyright (c) 2016, Matthew Bentley</p>
</body>
</html>
