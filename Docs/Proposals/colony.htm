<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>Introduction of std::colony to the standard library</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252">
</HEAD>
<BODY>
Audience: LEWG, SG14<br>
Document number: <br>
Date: 	2016-07-03<br>
Project: 	Introduction of std::colony to the standard library<br>
Reply-to: 	Matthew Bentley &lt;mattreecebentley@gmail.com&gt;<br>

<H1>Introduction of std::colony to the standard library</H1>


<H2>I. Introduction</H2>

<p>A colony is a C++ template-based unordered data container which provides
better performance than any std:: library container when:</p>
<ol type="a">
  <li>Insertions and erasures to the container are occuring frequently in
    realtime ie. in performance-critical code, <i><b>and/or</b></i> </li>
  <li>Pointers to non-erased container elements must not be invalidated by insertion or erasure.</li>
</ol>

<p>It's predominant field of usage is game development, but subsequent reports from high-performance computing and other domains have suggested it may be more generically useful. While the benchmarks referenced in the appendix are a better method for understanding the performance characteristics, the general speed characteristics are:</p>
<ul>
  <li><i>Insertion</i>: better than any std:: library container except some
    implementations of deque.</li>
  <li><i>Erasure</i>: better or equal to any std:: library container.</li>
  <li><i>Iteration</i>: better than any std:: library container where pointer
    validity is important. Where pointer validity is unimportant, better than
    any std:: library container except deque and vector.</li>
</ul>

<p>As explored in the benchmarks there are some vector/deque modifications/workarounds which can outperform
during iteration while maintaining pointer validity, but at a cost to usability
and memory use. Furthermore, when the ratio of insertions/erasures to iterations is greater than 1% insertions/erasures per 3600 full iterations over data, Colony tends to outperform these workarounds. Colony's other other advantages are freeing and recycling unused memory on-the-fly, the guaranteed stability of
pointers/references to non-erased elements regardless of insertion and erasure (which makes programming
with containers of interrelated data structures faster and much simpler). Iterators which do not point to end() or erased elements are also guaranteed to remain stable.</p>

<p>A colony is it's own abstract data type. It is most similar to a "bag", "bucket-array" or "multiset" ADT, but without key values. As it was initially developed predominantly for game development, colony favours small and large struct/class
performance over scalar-type performance.</p>


<H2>II. Motivation and Scope</H2>

<p>When working on video game engines we are predominantly dealing with collections of data where:<Br>
(<i>Note: These requirements match other areas of software development as well, but to simplify discussion I will focus on video game development</i>)</p>
<ol type="a">
<li>Elements within data collections refer to elements within other data collections (through a variety of methods - indices, pointers, etc). An example is a game entity referring to both a texture object and collision blocks, as well as sound data. These references must stay valid throughout the course of the game/level. For this reason, any container (or use of a container) which causes pointer or index invalidation can create difficulties or necessitate workarounds.</li>
<li>Order is unimportant for the most part. The majority of data collections are simply iterated over, transformed, referred to and utilized with no regard to order.</li>
<li>Storage of small-to-medium-sized classes and structs is the norm. Work with collections of small scalar types like int, double is far less common. Sometimes data can be stored in a SoA (Struct of Arrays) configuration, but these cases are somewhat less common.</li>
<li>Erasing or otherwise removing or deactivating objects occurs frequently in-game and in realtime (though often erasures will be implemented to occur at the end of a frame due to multithreading concerns). An example could be destroying a wall, or a game enemy. For this reason methods of erasure which create strong performance penalties are avoided.</li>
<li>Creating new objects and adding them into the gameworld on-the-fly is also common - for example, a tree which drops leaves every so often, or a quadtree.</li>
<li>We don't always know in advance how many elements there will be in a container at the beginning of development, or even at the beginning of a level during playback - an example of this being a MMORPG (massively multiplayer online role-playing game). In a MMORPG the number of game entities fluctuates based on how many players are playing, though there may be maximum capacity limits. Genericized game engines in particular have to adapt to considerably different user requirements and scopes. For this reason extensible containers which can expand and contract in realtime are usually necessary.</li>
<li>Depending on the complexity and scope of any given game, we can be dealing with anywhere between 10 and 100000 objects in a given area. We are not typically dealing with the types of capacities necessitated by large-scale mathematical or statistical applications.</li>
<li>For performance reasons, memory storage which is more-or-less contiguous is preferred. Lists, vectors of pointers to dynamically-allocated objects, and maps as implemented in the standard library are unusable.</li>
</ol>
<br>
<p>To meet these requirements, game developers tend to either (a) develop their own custom containers for given scenario or (b) develop workarounds for the failings of standard containers. These workarounds are many and varied, but the most common are probably:</p>
<ol>
<li>Inserting all data at the beginning of a level then never adding to the data, whilst using a boolean flag (or similar) to indicate the inactivity of an object (as opposed to actually erasing from the vector). When erasing, one simply adjusts the boolean flag, and when iterating, items with the adjusted boolean flag are skipped.</li>
<li>Utilizing a vector of data with a secondary vector of indexes. When erasing, the erasure occurs on the vector of indexes, not the vector of data, and when iterating, one iterates over the vector of indexes, then accessing the data from the vector of data via the index.</li>
</ol>
<br>
<p>The first technique has the advantage of fast erasure and simplicity of use, but is comparablty slow to iterate over and never frees memory to the OS. The second technique still has somewhat slow erasure but fast iteration, and also never frees memory to the OS. The first technique disallows insertion on the fly, as this invalidates pointer references. The second can maintain external references upon subsequent insertions, but only if the external object referencing the data knows both the container and the index, which complicates implementation. In addition, insertions will be slow due to the vector's need to reallocate once reaching capacity.</p>

<p>Colony is an attempt to bring a better and more generic solution to this area of work. It has the advantage of fast iteration while maintaining the same extremely fast erasure speed of the boolean technique described above, and without causing pointer/iterator invalidation upon either erasure or insertion. It's insertion speed is also faster than a vector's. Memory from erased elements is either reused by subsequent insertions or released to the OS on-the-fly.</p>


<H2>III. Impact On the Standard</H2>
<p>The only changes necessary to the standard are the introduction of std::colony and std::segmented_stack (separate proposal). std::segmented_stack (implemented <a href="http://www.plflib.org/stack.htm">here</a> as plf::stack) is used internally by colony and cannot be replaced by another type of container as it's relative performance and structure is also important to colony's overall performance. The reference implementation of colony is available <a href="http://www.plflib.org/colony.htm#download">here</a> as plf::colony.</p>

<h2>IV. Design Decisions</h2>
<p>There are three necessary aspects to colony which make it function as it does, and which define any
    implementation:</p>
    <ol>
      <li>A multiple-memory-block based allocation pattern which allows for the
        fast removal of memory blocks when they become empty of elements, regardless of their location.</li>
      <li>A skipfield to indicate erasures instead of reallocating elements,
        the iteration of which should typically not necessitate the use of
        branching code.</li>
      <li>A stack of erased element locations to allow for reuse of erased
        element memory space upon subsequent insertion.</li>
    </ol>
    <p>In the case of the reference implementation I utilize a doubly-linked intrusive list of 'group' structs containing (a) memory blocks, (b) memory block metadata and (c) skipfields. The linked-list pattern removes the possibility of non-O(1) operations when freeing empty memory blocks from the colony structure, compared to for example a vector of pointers to memory blocks. For the skipfield the reference implementation utilizes the <a href="http://www.plflib.org/the_jump_counting_skipfield_pattern.pdf">jump-counting
    skipfield pattern</a> which unlike a boolean skipfield allows for O(1) time complexity iterator operations. On current architectures it should be stated that it is preferable for any skipfield implementation to avoid branching operations for traversal. For the stack the reference implementation uses <a href="stack.htm">plf::stack</a>, submitted in a separate proposal as std::segmented_stack. This is due to it outperforming the standard library alternatives in benchmarking across compilers.</p>

<h2>V. Technical Specifications</h2>
<p>Key features of a colony are as follows:</li>
<ul>
<li>Unordered non-associative data container</li>
<li>Never invalidates pointers to non-erased elements</li>
<li>Reuses memory from erased elements or frees to OS</li>
<li>Performance is oriented towards small-large struct/class storage rather than scalar storage</li>
<li>In the context of general game data (as described), should be faster than any unmodified standard library container</li>
</ul>

<p>The full list of abstract requirements to support this is as follows:</p>
<ul>
<li>Uses multiple memory-blocks – prevents element reallocation on insertion
Blocks are freed to OS once empty</li>
<li>Blocks must be removable with low performance cost and without pointers to elements being invalidated</li>
<li>Has mechanism for reusing erased element locations upon insertion</li>
<li>Erased elements recorded in a skipfield, skipped over during iteration - prevents element reallocation on erasure</li>
<li>Skipfield design must allow for O(1) ++ and -- iteration</li>
</ul>

<h2>VI. Acknowledgements</h2>
<p>Thanks to Jonathan Blow for advice, Mike Acton for influence.</p>

<h2>VII. References</h2>

<h3>Reference implementation (plf::colony) benchmarks</h3>
<p>Benchmarks for GCC can be found <a href="http://plflib.org/colony.htm#benchmarks">here</a>, while benchmarks for MSVC can be found <a href="http://plflib.org/colony_benchmark_msvc_results.htm">here</a></p>


</BODY></HTML>