<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
  <title>Introduction of std::colony to the standard library</title>
  <style>
body {
    font-size: 12pt;
    font-family: Helvetica, Arial, sans-serif;
    font-weight: normal;
    font-style: normal;
    color: black;
    background-color: white;
    line-height: 1.2em;
    margin-left: 4em;
    margin-right: 2em;
   }

/* paragraphs */
p  {
    padding: 0;
    line-height: 1.3em;
    margin-top: 1em;
    margin-bottom: 1em;
    text-align: left;
   }

/* paragraphs */
table  {
    margin-top: 3.8em;
    margin-bottom: 2em;
    text-align: left;
   }
/* headings */
h1 {
    font-size: 195%;
    font-weight: bold;
    font-style: normal;
    font-variant: small-caps;
    line-height: 1.6em;
    text-align: left;
    padding: 0;
    margin-top: 3.5em;
    margin-bottom: 1.7em;
   }
h2 {
    font-size: 122%;
    font-weight: bold;
    font-style: normal;
    text-decoration: underline;
    padding: 0;
    margin-top: 4.5em;
    margin-bottom: 1.1em;
   }
h3 {
    font-size: 110%;
    font-weight: bold;
    font-style: normal;
    text-decoration: underline;
    padding: 0;
    margin-top: 4em;
    margin-bottom: 1.1em;
   }
h4 {
    font-size: 100%;
    font-weight: bold;
    font-style: normal;
    padding: 0;    
    margin-top: 4em;
    margin-bottom: 1.1em;
   }
h5 {
    font-size: 90%;
    font-weight: bold;
    font-style: italic;
    padding: 0;
    margin-top: 3em;
    margin-bottom: 1em;
   }
h6 {
    font-size: 80%;
    font-weight: bold;
    font-style: normal;
    padding: 0;
    margin-top: 1em;
    margin-bottom: 1em;
   }

/* divisions */
div {
    padding: 0;
    margin-top: 0em;
    margin-bottom: 0em;
   }

          ul {
           margin: 0pt 0pt 22pt 15.7pt;
           padding: 0pt 0pt 0pt 0pt;
           list-style-type: square;
           font-size: 10.5pt;
           font-family: sans-serif;
                        }
          ol {
           margin: 12pt 0pt 8pt 15.7pt;
           padding: 0pt 0pt 0pt 0pt;
           font-size: 10.5pt;
                        }
          li {
           margin: 0pt 0pt 10.5pt 0pt;
           padding: 0pt 0pt 0pt 0pt;
           text-indent: 0pt;
           font-size: 10.5pt;
           display: list-item;
           font-family: sans-serif;
                        }

/* inline */
strong {
    font-weight: bold;
   }
sup, sub {
   vertical-align: baseline;
   position: relative;
   top: -0.4em;
   font-size: 70%;
}
sub { top: 0.4em; }
em {
    font-style: italic;
   }
code {
    font-family: Courier New, Courier, monospace;
    font-size: 90%;
    padding: 0 0 0 0em;
   }
ins {
    background-color: yellow;
    text-decoration: underline;
   }
del {
    text-decoration: line-through;
   }


                a:hover {
                  color: #4398E1;
                  }

                a:active {
                  color: #4598E1;
                  text-decoration: none;
                  }

                a:link.review {
                  color: #AAAAAF;
                  }

                a:hover.review {
                  color: #4398E1;
                  }

                a:visited.review {
                  color: #444444;
                  }

                a:active.review {
                  color: #AAAAAF;
                  text-decoration: none;
                  }</style>
  <meta http-equiv="content-type" content="text/html; charset=windows-1252">
</head>

<body>
Audience: LEWG, SG14<br>
Document number: D0447R0<br>
Date: 2016-07-03<br>
Project: Introduction of std::colony to the standard library<br>
Reply-to: Matthew Bentley &lt;mattreecebentley@gmail.com&gt;<br>


<h1>Introduction of std::colony to the standard library</h1>

<h2>I. Introduction</h2>

<p>Sometimes while programming we come across situations where order is
unimportant, but where data is heavily interlinked, iterated over frequently,
and changing often. Computer games are one obvious example, but scenarios like
this crop up in other fields from data storage to high-performance computing.
id lookups are quite slow compared to direct pointers, and anything in the
standard library that isn't vector is quite slow to iterate over<sup><a
href="#benchmarks">[1]</a></sup>, but vector loses pointer validity upon
insertion and pointer/index validity upon erasure; leading to complicated or
less-performant workarounds. Colony is a specifically-unordered (but sortable)
templated data container which allows for fast iteration and direct pointer
lookups, without losing pointer validaty to non-erased elements after
erasing/inserting.</p>

<p>In short, Colony has better performance than any standard library container
when:</p>
<ol type="a">
  <li>Insertions and erasures to the container are occuring frequently in
    realtime ie. in performance-critical code, <i><b>and/or</b></i> </li>
  <li>Pointers to non-erased container elements must not be invalidated by
    insertion or erasure.</li>
</ol>

<p>It's envisioned field of usage during development was game development but
subsequent reports from high-performance computing and other domains have
suggested it may be more generically useful. While benchmarks referenced in the
appendix are a better method for understanding the performance characteristics,
the general speed characteristics are:</p>
<ul>
  <li><i>Insertion</i>: better than any std:: library container except some
    implementations of deque.</li>
  <li><i>Erasure</i>: better or equal to any std:: library container.</li>
  <li><i>Iteration</i>: better than any std:: library container where pointer
    validity is important. Where pointer validity is unimportant, better than
    any std:: library container except deque and vector.</li>
</ul>

<p>As explored in the benchmarks there are some vector/deque
modifications/workarounds which can outperform during iteration while
maintaining pointer validity, but at a cost to usability and memory use.
Furthermore, when the ratio of insertions/erasures to iterations is greater
than 1% insertions/erasures per 3600 full iterations over data, Colony tends to
outperform these workarounds. Colony's other other advantages are freeing and
recycling unused memory on-the-fly, the guaranteed stability of
pointers/references to non-erased elements regardless of insertion and erasure
(which makes programming with containers of interrelated data structures faster
and much simpler). Iterators which do not point to end() or erased elements are
also guaranteed to remain stable.</p>

<p>A colony is it's own abstract data type. It is most similar to a "bag",
"bucket-array" or "multiset" ADT, but without key values. As it was initially
developed predominantly for game development, colony favours small and large
struct/class performance over scalar type performance.</p>

<h2>II. Motivation and Scope</h2>

<p>When working on video game engines we are predominantly dealing with
collections of data where:<br>
(<i>Note: These requirements match other areas of software development as well,
but to simplify discussion I will focus on video game development</i>)</p>
<ol type="a">
  <li>Elements within data collections refer to elements within other data
    collections (through a variety of methods - indices, pointers, etc). An
    example is a game entity referring to both a texture object and collision
    blocks, as well as sound data. These references must stay valid throughout
    the course of the game/level. For this reason, any container (or use of a
    container) which causes pointer or index invalidation can create
    difficulties or necessitate workarounds.</li>
  <li>Order is unimportant for the most part. The majority of data collections
    are simply iterated over, transformed, referred to and utilized with no
    regard to order.</li>
  <li>Storage of small-to-medium-sized classes and structs is the norm. Work
    with collections of small scalar types like int, double is far less common.
    Sometimes data can be stored in a SoA (Struct of Arrays) configuration, but
    these cases are somewhat less common.</li>
  <li>Erasing or otherwise removing or deactivating objects occurs frequently
    in-game and in realtime (though often erasures will be implemented to occur
    at the end of a frame due to multithreading concerns). An example could be
    destroying a wall, or a game enemy. For this reason methods of erasure
    which create strong performance penalties are avoided.</li>
  <li>Creating new objects and adding them into the gameworld on-the-fly is
    also common - for example, a tree which drops leaves every so often, or a
    quadtree.</li>
  <li>We don't always know in advance how many elements there will be in a
    container at the beginning of development, or even at the beginning of a
    level during playback - an example of this being a MMORPG (massively
    multiplayer online role-playing game). In a MMORPG the number of game
    entities fluctuates based on how many players are playing, though there may
    be maximum capacity limits. Genericized game engines in particular have to
    adapt to considerably different user requirements and scopes. For this
    reason extensible containers which can expand and contract in realtime are
    usually necessary.</li>
  <li>Depending on the complexity and scope of any given game, we can be
    dealing with anywhere between 10 and 100000 objects in a given area. We are
    not typically dealing with the types of capacities necessitated by
    large-scale mathematical or statistical applications.</li>
  <li>For performance reasons, memory storage which is more-or-less contiguous
    is preferred. Lists, vectors of pointers to dynamically-allocated objects,
    and maps as implemented in the standard library are unusable.</li>
  <li>Memory wastage is avoided, and in particular, any container which
    allocates upon initialisation tends to be avoided as this can incur
    purposeless memory and performance costs.</li>
</ol>
<br>


<p>std::vector in it's default state does not meet these requirements:</p>
<ol>
  <li>Poor erasure performance for large amounts of data (even with remove_if
    duration is highly variable)</li>
  <li>Poor insertion (non-fll) performance due to reallocation </li>
  <li>Insert invalidates pointers/iterators to all elements </li>
  <li>Erase invalidates pointers/iterators/indexes to all elements afer the
    erased element </li>
  <li>Requires single contiguous memory block (typically larger than cache
    lines) which increases chance of allocation failures for large amounts of
    data on insert</li>
</ol>

<p>To meet these requirements, game developers tend to either (a) develop their
own custom containers for given scenario or (b) develop workarounds for the
failings of vector. These workarounds are many and varied, but the most common
are probably:</p>
<ol>
  <li>Using a boolean flag (or similar) to indicate the inactivity of an object
    (as opposed to actually erasing from the vector). When erasing, one simply
    adjusts the boolean flag, and when iterating, items with the adjusted
    boolean flag are skipped. External elements refer to elements within the
    container via indexes rather than pointers (which can be invalidated upon
    insertion). 
    <p>Advantages: Fast erasure.</p>
    <p>Disadvantages: Slow to iterate due to branching.</p>
  </li>
  <li>Utilizing a vector of data with a secondary vector of indexes. When
    erasing, the erasure occurs in the vector of indexes, not the vector of
    data, and when iterating, one iterates over the vector of indexes, then
    accessing the data from the vector of data via the index. 
    <p>Advantages: Faster iteration.</p>
    <p>Disadvantages: Erasure still incurs some reallocation cost, can increase
    jitter.</p>
  </li>
  <li>Combining a swap-and-pop mechanism with some form of dereferenced lookup
    system to enable contiguous element iteration (known as a 'packed array',
    or various other names). This technique allows for standard vector
    iteration speed, but decreases lookup and referential performance. Erasure
    speed is also fast unless elements are large and/or non-trivially
  swappable.</li>
</ol>
<br>


<p>All three techniques have the disadvantage of slow singular insertions, and
the first two will also continually expand memory usage when erasing and
inserting over periods of time. The third deals better with this scenario as it
swaps from the back rather than leaving gaps in the elements vector, however
will suffer in performance if elements within the container are heavily
referred to by external objects/elements, or if the elements are large and
swap/copy is non-trivial.</p>

<p>Colony is an attempt to bring a more generic solution to this domain. It has
the advantage of good iteration speed while maintaining a similar erasure speed
to the boolean technique described above, and without causing pointer
invalidation (to non-erased elements) during erasure or insertion. It's
insertion speed is much faster than a vector's and similar to a good deque
implementation's. Memory from erased elements is either reused by subsequent
insertions or released to the OS on-the-fly. It achieves these ends by via a
number of new approaches: a <a
href="http://www.plflib.org/the_jump_counting_skipfield_pattern.pdf">jump-counting
skipfield</a> (instead of a boolean field), a <a
href="chained_group_allocation_pattern.htm">linked chain</a> of
increasingly-large memory blocks (instead of a singular memory block or vector
of blocks), and an internal high-performance stack structure to enable erased
memory location re-use.</p>

<p>The current reference implementation has been receiving feedback for the past two years from members of the Boost and SG14 groups as well as general independent C++ users.</p>

<h2>III. Impact On the Standard</h2>

<p>No changes are necessary to the standard, asides from the introduction of
the colony container. The reference implementation of colony is available <a
href="http://www.plflib.org/colony.htm#download">here</a> as plf::colony.</p>

<h2>IV. Design Decisions</h2>

<p>The key technical features of a colony are as follows:</p>
<ul>
  <li>Unordered non-associative data container</li>
  <li>Never invalidates pointers to non-erased elements</li>
  <li>Reuses memory from erased elements or frees to OS</li>
  <li>Performance is oriented towards small-large struct/class storage rather
    than scalar storage</li>
  <li>In the context of general game data (as described), should be faster than
    any unmodified standard library container</li>
  <li>Iterators to non-erased elements guaranteed to stay valid unless iterator
    == end()</li>
</ul>

<p>The full list of abstract requirements to support these features are as
follows:</p>
<ul>
  <li>Must use multiple memory-blocks as this prevents element reallocation on
    insertion</li>
  <li>Blocks must be freed to the OS once empty</li>
  <li>Blocks must be removable with low performance cost and without pointers
    to elements being invalidated</li>
  <li>Must have a mechanism for reusing erased element locations upon
  insertion</li>
  <li>Erased elements are recorded in a skipfield, skipped over during
    iteration - prevents element reallocation on erasure</li>
  <li>Skipfield design must allow for O(1) ++ and -- iteration</li>
</ul>

<p>To simplify we can say there are three necessary aspects to colony which make it function as it
does, and which define any implementation:</p>
<ol>
  <li>A multiple-memory-block based allocation pattern which allows for the
    fast removal of memory blocks when they become empty of elements,
    regardless of their location, and without pointer invalidation.</li>
  <li>A skipfield to indicate erased elements, the iteration of which should not necessitate the use of branching
    code.</li>
  <li>A mechanism for reusing erased element locations upon subsequent insertions.</li>
</ol>


<p>In the case of the reference implementation I utilized a <a href="http://www.plflib.org/chained_group_allocation_pattern.htm">chained-group allocation pattern</a> for the memory blocks - ie. a doubly-linked
intrusive list of 'group' structs containing (a) memory blocks, (b) memory
block metadata and (c) skipfields. This linked-list-style pattern removes the
possibility of non-O(1) operations when freeing empty memory blocks from the
colony structure, compared to a vector of pointers to memory blocks. A vector
of pointers to memory blocks may however enable faster insertions while
increasing implementation complexity. Comparitive benchmarks would be necessary
to establish overall optimal approach.</p>

<p>For the skipfield a boolean skipfield cannot be used:</p>
<ul>
  <li>++ iteration is O(random), iterators require O(1) operations </li>
  <li>Any boolean skipfeld creates branching code in the iterator </li>
  <li>Dependent on CPU branch prediction for performance </li>
  <li>Iterator code complexity </li>
  <li>Waste of 7 bits (and 254 states) per element if aiming for speed
    (byte-level addressing- bool or char) rather than storage size (bitfeld -
    slower)</li>
</ul>

<p>For these reasons the reference implementation instead utilizes the <a
href="http://www.plflib.org/the_jump_counting_skipfield_pattern.pdf">jump-counting
skipfield pattern</a> which allows for O(1) time complexity iterator operations
and performs better due to a lack of branching.</p>

<h6>Iteration performance of vector with boolean skipfield vs colony with
boolean skipfield vs colony with jump-counting skipfield (GCC5):</h6>
<a
href="http://www.plflib.org/tests/gcc/colony/jump_counting/jump_counting_comparison_iteration_25.png"><img
alt="test result graph" height="25%" width="25%"
src="http://www.plflib.org/tests/gcc/colony/jump_counting/jump_counting_comparison_iteration_25.png"></a> 

<p>For the erased location re-use mechanism, the reference implementation uses
a stripped-down custom internal stack class based on <a
href="http://www.plflib.org/stack.htm">plf::stack</a> (plf::stack outperforms
other std:: containers in a stack context across compilers).</p>

<h6>Time to push all elements + read-and-pop all elements, plf::stack vs
std::stack (std::deque) vs std::vector (GCC5):</h6>
<a
href="http://www.plflib.org/tests/gcc/stack/small_struct_total_time.png"><img
alt="test result graph" width="25%" height="25%"
src="http://www.plflib.org/tests/gcc/stack/small_struct_total_time.png"></a> 

<p>An alternative route of using a "free list" of erased elements for the
re-use mechanism has been explored and the following problems identified:</p>
<ol>
  <li>A colony element could be smaller in size than a pointer and thus a union
    with such would dramatically increase the amount of wasted space - moreso
    if the pointer type supplied by the allocator is non-trivial.</li>
  <li>Given that a free list will jump between colony groups a lot,
    consolidating a free list after removing empty groups from a colony would
    typically result in a very slow operation filled with cache misses.</li>
</ol>

<h2>V. Technical Specifications</h2>

<p>Colony meets the requirements of the C++ <a
href="http://en.cppreference.com/w/cpp/concept/Container">Container</a>, <a
href="http://en.cppreference.com/w/cpp/concept/AllocatorAwareContainer">AllocatorAwareContainer</a>,
and <a
href="http://en.cppreference.com/w/cpp/concept/ReversibleContainer">ReversibleContainer</a>
concepts.</p>

<p>For the most part the syntax and semantics of colony functions are very
similar to all std:: c++ libraries. Formal description is as follows:</p>
<code>template &lt;class T, class Allocator = std::allocator&lt;T&gt;, typename
Skipfield_Type = unsigned short&gt; class colony</code> 

<p><code><b>T</b></code> - the element type. In general T must meet the
requirements of <a
href="http://en.cppreference.com/w/cpp/concept/Erasable">Erasable</a>, <a
href="http://en.cppreference.com/w/cpp/concept/CopyAssignable">CopyAssignable</a>
and <a
href="http://en.cppreference.com/w/cpp/concept/CopyConstructible">CopyConstructible</a>.<br>
However, if emplace is utilized to insert elements into the colony, and no
functions which involve copying or moving are utilized, T is only required to
meet the requirements of <a
href="http://en.cppreference.com/w/cpp/concept/Erasable">Erasable</a>.<br>
If move-insert is utilized instead of emplace, T must also meet the
requirements of <a
href="http://en.cppreference.com/w/cpp/concept/MoveConstructible">MoveConstructible</a>
 .<br>
<br>
<code><b>Allocator</b></code> - an allocator that is used to acquire memory to
store the elements. The type must meet the requirements of <a
href="http://en.cppreference.com/w/cpp/concept/Allocator">Allocator</a>. The
behavior is undefined if <code>Allocator::value_type</code> is not the same as
T.<br>
<br>
<code><b>Skipfield_Type</b></code> - an unsigned integer type. This type is
used to create the skipfield and the maximum size of element memory blocks is
constrained by it's bit-depth due to the nature of a jump-counting skipfield.
For example, <code>unsigned short</code> on most platforms is 16-bit and
therefore constrains the size of individual memory blocks to a maximum of 65535
elements. <code>unsigned short</code> has been found to be the optimal type for
performance based on benchmarking. However there may be some memory-constrained
situations where element block allocations of more than 255 elements at a time
would not be desirable. In these situations, <code>unsigned char</code> may be
used for the skipfield instead, resulting in some additional memory usage
saving for the skipfield itself. It is unlikely for there to be any
circumstances which benefit from a skipfield bit-depth greater than
<code>unsigned short</code>. If <code>Skipfield_Type</code> is not an unsigned
integer type, behaviour is undefined. </p>

<h4>Basic example of usage</h4>

<div
style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;">
<pre style="margin: 0; line-height: 125%"><code><span style="color: #557799">#include &lt;iostream&gt;</span>
<span style="color: #557799">#include "plf_colony.h"</span>

<span style="color: #333399; font-weight: bold">int</span> <span style="color: #0066BB; font-weight: bold">main</span>(<span style="color: #333399; font-weight: bold">int</span> argc, <span style="color: #333399; font-weight: bold">char</span> <span style="color: #333333">**</span>argv)
{
  plf<span style="color: #333333">::</span>colony<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">int</span><span style="color: #333333">&gt;</span> i_colony;

  <span style="color: #888888">// Insert 100 ints:</span>
  <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">int</span> i <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; i <span style="color: #333333">!=</span> <span style="color: #0000DD; font-weight: bold">100</span>; <span style="color: #333333">++</span>i)
  {
    i_colony.insert(i);
  }

  <span style="color: #888888">// Erase half of them:</span>
  <span style="color: #008800; font-weight: bold">for</span> (plf<span style="color: #333333">::</span>colony<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">int</span><span style="color: #333333">&gt;::</span>iterator it <span style="color: #333333">=</span> i_colony.begin(); it <span style="color: #333333">!=</span> i_colony.end(); <span style="color: #333333">++</span>it)
  {
    it <span style="color: #333333">=</span> i_colony.erase(it);
  }

  <span style="color: #888888">// Total the remaining ints:</span>
  <span style="color: #333399; font-weight: bold">int</span> total <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>;

  <span style="color: #008800; font-weight: bold">for</span> (plf<span style="color: #333333">::</span>colony<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">int</span><span style="color: #333333">&gt;::</span>iterator it <span style="color: #333333">=</span> i_colony.begin(); it <span style="color: #333333">!=</span> i_colony.end(); <span style="color: #333333">++</span>it)
  {
    total <span style="color: #333333">+=</span> <span style="color: #333333">*</span>it;
  }

  std<span style="color: #333333">::</span>cout <span style="color: #333333">&lt;&lt;</span> <span style="background-color: #fff0f0">"Total: "</span> <span style="color: #333333">&lt;&lt;</span> total <span style="color: #333333">&lt;&lt;</span> std<span style="color: #333333">::</span>endl;
  std<span style="color: #333333">::</span>cin.get();
  <span style="color: #008800; font-weight: bold">return</span> <span style="color: #0000DD; font-weight: bold">0</span>;
} </code></pre>
</div>

<h4>Example demonstrating pointer stability</h4>

<div
style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;">
<pre style="margin: 0; line-height: 125%"><code><span style="color: #557799">#include &lt;iostream&gt;</span>
<span style="color: #557799">#include "plf_colony.h"</span>

<span style="color: #333399; font-weight: bold">int</span> <span style="color: #0066BB; font-weight: bold">main</span>(<span style="color: #333399; font-weight: bold">int</span> argc, <span style="color: #333399; font-weight: bold">char</span> <span style="color: #333333">**</span>argv)
{
  plf<span style="color: #333333">::</span>colony<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">int</span><span style="color: #333333">&gt;</span> i_colony;
  plf<span style="color: #333333">::</span>colony<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">int</span><span style="color: #333333">&gt;::</span>iterator it;
  plf<span style="color: #333333">::</span>colony<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">int</span> <span style="color: #333333">*&gt;</span> p_colony;
  plf<span style="color: #333333">::</span>colony<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">int</span> <span style="color: #333333">*&gt;::</span>iterator p_it;

  <span style="color: #888888">// Insert 100 ints to i_colony and pointers to those ints to p_colony:</span>
  <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">int</span> i <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; i <span style="color: #333333">!=</span> <span style="color: #0000DD; font-weight: bold">100</span>; <span style="color: #333333">++</span>i)
  {
    it <span style="color: #333333">=</span> i_colony.insert(i);
    p_colony.insert(<span style="color: #333333">&amp;</span>(<span style="color: #333333">*</span>it));
  }

  <span style="color: #888888">// Erase half of the ints:</span>
  <span style="color: #008800; font-weight: bold">for</span> (it <span style="color: #333333">=</span> i_colony.begin(); it <span style="color: #333333">!=</span> i_colony.end(); <span style="color: #333333">++</span>it)
  {
    it <span style="color: #333333">=</span> i_colony.erase(it);
  }

  <span style="color: #888888">// Erase half of the int pointers:</span>
  <span style="color: #008800; font-weight: bold">for</span> (p_it <span style="color: #333333">=</span> p_colony.begin(); p_it <span style="color: #333333">!=</span> p_colony.end(); <span style="color: #333333">++</span>p_it)
  {
    p_it <span style="color: #333333">=</span> p_colony.erase(p_it);
  }

  <span style="color: #888888">// Total the remaining ints via the pointer colony (pointers will still be valid even after insertions and erasures):</span>
  <span style="color: #333399; font-weight: bold">int</span> total <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>;

  <span style="color: #008800; font-weight: bold">for</span> (p_it <span style="color: #333333">=</span> p_colony.begin(); p_it <span style="color: #333333">!=</span> p_colony.end(); <span style="color: #333333">++</span>p_it)
  {
    total <span style="color: #333333">+=</span> <span style="color: #333333">*</span>(<span style="color: #333333">*</span>p_it);
  }

  std<span style="color: #333333">::</span>cout <span style="color: #333333">&lt;&lt;</span> <span style="background-color: #fff0f0">"Total: "</span> <span style="color: #333333">&lt;&lt;</span> total <span style="color: #333333">&lt;&lt;</span> std<span style="color: #333333">::</span>endl;
  
  <span style="color: #008800; font-weight: bold">if</span> (total <span style="color: #333333">==</span> <span style="color: #0000DD; font-weight: bold">2500</span>)
  {
    std<span style="color: #333333">::</span>cout <span style="color: #333333">&lt;&lt;</span> <span style="background-color: #fff0f0">"Pointers still valid!"</span> <span style="color: #333333">&lt;&lt;</span> std<span style="color: #333333">::</span>endl;
  }
  
  std<span style="color: #333333">::</span>cin.get();
  <span style="color: #008800; font-weight: bold">return</span> <span style="color: #0000DD; font-weight: bold">0</span>;
} </code></pre>
</div>

<h4>Iterator Invalidation</h4>

<table border="1">
  <tbody>
    <tr>
      <td>All read-only operations, swap, std::swap</td>
      <td>Never</td>
    </tr>
    <tr>
      <td>clear, reinitialize, operator = </td>
      <td>Always</td>
    </tr>
    <tr>
      <td>reserve, shrink_to_fit</td>
      <td>Only if capacity is changed</td>
    </tr>
    <tr>
      <td>change_group_sizes, change_minimum_group_size,
        change_maximum_group_size</td>
      <td>Only if supplied minimum group size is larger than smallest group in
        colony, or supplied maximum group size is smaller than largest group in
        colony.</td>
    </tr>
    <tr>
      <td>erase</td>
      <td>Only for the erased element</td>
    </tr>
    <tr>
      <td>insert, emplace</td>
      <td>If an iterator is == end() it may be invalidated by a subsequent
        insert/emplace in some cases. Otherwise no.</td>
    </tr>
  </tbody>
</table>

<h4>Member types</h4>

<table border="1">
  <tbody>
    <tr>
      <td><b>Member type</b></td>
      <td><b>Definition</b></td>
    </tr>
    <tr>
      <td><code>value_type</code></td>
      <td><code>T</code></td>
    </tr>
    <tr>
      <td><code>allocator_type</code></td>
      <td><code>Allocator</code></td>
    </tr>
    <tr>
      <td><code>size_type</code></td>
      <td><code>Allocator::size_type (pre-c++11)<br>
        std::allocator_traits&lt;Allocator&gt;::size_type
      (post-c++11)</code></td>
    </tr>
    <tr>
      <td><code>difference_type</code></td>
      <td><code>Allocator::difference_type (pre-c++11)<br>
        std::allocator_traits&lt;Allocator&gt;::difference_type
        (post-c++11)</code></td>
    </tr>
    <tr>
      <td><code>reference</code></td>
      <td><code>Allocator::reference (pre-c++11)<br>
        value_type &amp; (post-c++11)</code></td>
    </tr>
    <tr>
      <td><code>const_reference</code></td>
      <td><code>Allocator::const_reference (pre-c++11)<br>
        const value_type &amp; (post-c++11)</code></td>
    </tr>
    <tr>
      <td><code>pointer</code></td>
      <td><code>Allocator::pointer (pre-c++11)<br>
        value_type &amp; (post-c++11)</code></td>
    </tr>
    <tr>
      <td><code>const_pointer</code></td>
      <td><code>Allocator::const_pointer (pre-c++11)<br>
        std::allocator_traits&lt;Allocator&gt;::const_pointer
        (post-c++11)</code></td>
    </tr>
    <tr>
      <td><code>iterator</code></td>
      <td><code>BidirectionalIterator</code></td>
    </tr>
    <tr>
      <td><code>const_iterator</code></td>
      <td><code>Constant BidirectionalIterator</code></td>
    </tr>
    <tr>
      <td><code>reverse_iterator</code></td>
      <td><code>BidirectionalIterator</code></td>
    </tr>
    <tr>
      <td><code>const_reverse_iterator</code></td>
      <td><code>Constant BidirectionalIterator</code></td>
    </tr>
  </tbody>
</table>

<p>Iterators are bidirectional but in the reference implementation also
additionally support &gt;, &lt;, &gt;= and &lt;= operators for convenience.</p>

<p>Member overloads for the standard library functions advance(), next(),
prev() and distance() are also available in the reference implementation. These
are significantly faster in most cases for colony than the equivalent standard
functions.</p>


<h3>Constructors</h3>

<table border="1">
  <tbody>
    <tr>
      <td>default</td>
      <td><code>explicit colony(const allocator_type &amp;alloc =
        allocator_type())</code></td>
    </tr>
    <tr>
      <td>fill</td>
      <td><code>explicit colony(const size_type n, const unsigned short
        min_group_size = 8, const unsigned short max_group_size =
        std::numeric_limits&lt;Skipfield_type&gt;::max(), const allocator_type
        &amp;alloc = allocator_type())<br>
        explicit colony(const size_type n, const value_type &amp;element, const
        unsigned short min_group_size = 8, const unsigned short max_group_size
        = std::numeric_limits&lt;Skipfield_type&gt;::max(), const
        allocator_type &amp;alloc = allocator_type()) </code></td>
    </tr>
    <tr>
      <td>range</td>
      <td><code>template&lt;typename InputIterator&gt; colony(const
        InputIterator &amp;first, const InputIterator &amp;last, const unsigned
        short min_group_size = 8, const unsigned short max_group_size =
        std::numeric_limits&lt;Skipfield_type&gt;::max(), const allocator_type
        &amp;alloc = allocator_type())<br>
        </code></td>
    </tr>
    <tr>
      <td>copy</td>
      <td><code>colony(const colony &amp;source)</code></td>
    </tr>
    <tr>
      <td>move</td>
      <td><code>colony(colony &amp;&amp;source) noexcept <font size="2">(C++11
        and upwards)</font></code></td>
    </tr>
    <tr>
      <td>initializer list</td>
      <td><code>colony(const std::initializer_list&lt;value_type&gt;
        &amp;element_list, const unsigned short min_group_size = 8, const
        unsigned short max_group_size =
        std::numeric_limits&lt;Skipfield_type&gt;::max(), const allocator_type
        &amp;alloc = allocator_type()) </code></td>
    </tr>
  </tbody>
</table>

<p>The reference implementation's full function listing is available in the references<sup><a href="#functions">2</a></sup>.

<p>Specific implementation details on the main three aspects of the reference
implementation are too large to be included in this document, but are available
here as external links:<br>
Details on colony's reference implementation and functions, can be found <a href="http://www.plflib.org/colony.htm">here</a>, including a FAQ.<br>
Details on the chained-group allocation pattern are <a
href="http://www.plflib.org/chained_group_allocation_pattern.htm">here</a>.<br>
Details on the jump-counting skipfield pattern are <a
href="http://www.plflib.org/chained_group_allocation_pattern.htm">here</a>, and
benchmarks versus boolean skipfields are presented <a
href="http://www.plflib.org/skipfield_comparison.htm">here</a>.<br>
Lastly, plf::stack (on which the reference implementation's stack
implementation is based) is explained in detail <a
href="http://www.plflib.org/stack.htm">here</a>.</p>

<p>The reference implementation of colony is available to download <a
href="http://www.plflib.org/colony.htm#download">here</a> or via the <a
href="https://github.com/mattreecebentley/plf_colony">github repository</a>.</p>

<h2>VI. Acknowledgements</h2>

<p>Thanks to Glen Fernandes and Ion Gaztanaga for restructuring advice, Robert
Ramey for documentation advice, various Boost and SG14 members for support,
suggestions and bug reports including Sean Middleditch, Patrice Roy and Guy
Davidson. And that jerk from Lionhead for annoying me enough to force me to
finally implement the jump-counting skipfield pattern. Lastly, thanks to Jon
Blow for initial advice and Mike Acton for some positive influence.</p>

<h2>VII. References</h2>

<h3><a id="#benchmarks"></a>plf::colony benchmarks</h3>

<p>Benchmarks for GCC can be found <a
href="http://plflib.org/colony.htm#benchmarks">here</a>, while benchmarks for
MSVC can be found <a
href="http://plflib.org/colony_benchmark_msvc_results.htm">here</a></p>
</body>

<h3><a id="#functions"></a>Member functions</h3>

<h4>Insert</h4>

<table border="1">
  <tbody>
    <tr>
      <td>single element</td>
      <td><code>iterator insert (const value_type &amp;val)</code></td>
    </tr>
    <tr>
      <td>fill</td>
      <td><code>iterator insert (const size_type n, const value_type
        &amp;val)</code></td>
    </tr>
    <tr>
      <td>range</td>
      <td><code>template &lt;class InputIterator&gt; iterator insert (const
        InputIterator &amp;first, const InputIterator &amp;last)</code></td>
    </tr>
    <tr>
      <td>move</td>
      <td><code>iterator insert (value_type&amp;&amp; val) <font
        size="2">(C++11 and upwards)</font></code></td>
    </tr>
    <tr>
      <td>initializer list</td>
      <td><code>iterator insert (const std::initializer_list&lt;value_type&gt;
        &amp;il)</code></td>
    </tr>
  </tbody>
</table>
<ul>
  <li><code>iterator insert(const value_type &amp;element)</code> 
    <p>Inserts the element supplied to the colony, using the object's
    copy-constructor. Will insert the element into a previously erased element
    slot if one exists, otherwise will insert to back of colony. Returns
    iterator to location of inserted element. Example:</p>
    <code style="color: brown">plf::colony&lt;unsigned int&gt; i_colony;<br>
    i_colony.insert(23);</code> </li>
  <li><code>iterator insert (const size_type n, const value_type
    &amp;val)</code> 
    <p>Inserts <code>n</code> copies of <code>val</code> into the colony. Will
    insert the element into a previously erased element slot if one exists,
    otherwise will insert to back of colony. Returns iterator to location of
    first inserted element. Example:</p>
    <code style="color: brown">plf::colony&lt;unsigned int&gt; i_colony;<br>
    i_colony.insert(10, 3);</code> </li>
  <li><code>template &lt;class InputIterator&gt; iterator insert (const
    InputIterator &amp;first, const InputIterator &amp;last)</code> 
    <p>Inserts a series of <code>value_type</code> elements from an external
    source into a colony holding the same <code>value_type</code> (eg. int,
    float, a particular class, etcetera). Stops inserting once it reaches
    <code>last</code>. Example:</p>
    <code style="color: brown">// Insert all contents of colony2 into
    colony1:<br>
    colony1.insert(colony2.begin(), colony2.end());</code> </li>
  <li><code>iterator insert(value_type &amp;&amp;element) <b>C++11 and
    upwards</b></code> 
    <p>Moves the element supplied to the colony, using the object's
    move-constructor. Will insert the element in a previously erased element
    slot if one exists, otherwise will insert to back of colony. Returns
    iterator to location of inserted element. Example:</p>
    <p><code style="color: brown">std::string string1 = "Some text";<br>
    <br>
    plf::colony&lt;std::string&gt; data_colony;<br>
    data_colony.insert(std::move(string1));</code></p>
  </li>
  <li><code>iterator insert (const std::initializer_list&lt;value_type&gt;
    &amp;il)</code> 
    <p>Moves the element supplied to the colony, using the object's
    move-constructor. Will insert the element in a previously erased element
    slot if one exists, otherwise will insert to back of colony. Returns
    iterator to location of inserted element. Example:</p>
    <p><code style="color: brown">std::initializer_list&lt;int&gt; some_ints =
    {4, 3, 2, 5};<br>
    <br>
    plf::colony&lt;int&gt; i_colony;<br>
    i_colony.insert(some_ints);</code></p>
  </li>
</ul>

<h4>Erase</h4>

<table border="1">
  <tbody>
    <tr>
      <td>single element</td>
      <td><code>iterator erase(const iterator &amp;it)</code></td>
    </tr>
    <tr>
      <td>range</td>
      <td><code>void erase(const iterator &amp;first, const iterator
        &amp;last)</code></td>
    </tr>
  </tbody>
</table>
<ul>
  <li><code>iterator erase(const iterator &amp;it)</code>
    <p>Removes the element pointed to by the supplied iterator, from the
    colony. Returns an iterator pointing to the next non-erased element in the
    colony (or to end() if no more elements are available). This must return an
    iterator because if a colony group becomes entirely empty, it will be
    removed from the colony, invalidating the existing iterator. Attempting to
    erase a previously-erased element results in undefined behaviour (this is
    checked for via an assert in debug mode). Example:</p>
    <code style="color: brown">plf::colony&lt;unsigned int&gt;
    data_colony(50);<br>
    plf::colony&lt;unsigned int&gt;::iterator an_iterator;<br>
    an_iterator = data_colony.insert(23);<br>
    an_iterator = data_colony.erase(an_iterator);</code> </li>
  <li><code>void erase(const iterator &amp;first, const iterator
    &amp;last)</code> 
    <p>Erases all contents of a given colony from <code>first</code> to the
    element before the <code>last</code> iterator. Example:</p>
    <code style="color: brown">plf::colony&lt;int&gt; iterator1 =
    colony1.begin();<br>
    colony1.advance(iterator1, 10);<br>
    plf::colony&lt;int&gt; iterator2 = colony1.begin();<br>
    colony1.advance(iterator2, 20);<br>
    colony1.erase(iterator1, iterator2);</code> </li>
</ul>

<h4>Other functions</h4>
<ul>
  <li><code>iterator emplace(Arguments ...parameters) <b>C++11 and
    upwards</b></code> 
    <p>Constructs new element directly within colony. Will insert the element
    in a previously erased element slot if one exists, otherwise will insert to
    back of colony. Returns iterator to location of inserted element.
    "...parameters" are whatever parameters are required by the object's
    constructor. Example:</p>
    <p><code style="color: brown">class simple_class<br>
    {<br>
    private:<br>
    &nbsp; int number;<br>
    public:<br>
    &nbsp; simple_class(int a_number): number (a_number) {};<br>
    };<br>
    <br>
    plf::colony&lt;simple_class&gt; simple_classes;<br>
    simple_classes.emplace(45); </code> </p>
  </li>
  <li><code>bool empty()</code> 
    <p>Returns a boolean indicating whether the colony is currently empty of
    elements.<br>
    Example: <code style="color: brown">if (object_colony.empty())
    return;</code></p>
  </li>
  <li><code>size_type size()</code> 
    <p>Returns total number of elements currently stored in container.<br>
    Example: <code style="color: brown">std::cout &lt;&lt; i_colony.size()
    &lt;&lt; std::endl;</code></p>
  </li>
  <li><code>size_type max_size()</code> 
    <p>Returns the maximum number of elements that the allocator can store in
    the container. This is an approximation as it does attempt to measure the
    memory overhead of the container's internal memory structures. It is not
    possible to measure the latter because a copy operation may change the
    number of groups utilized for the same amount of elements, if the maximum
    or minimum group sizes are different in the source container.<br>
    Example: <code style="color: brown">std::cout &lt;&lt; i_colony.max_size()
    &lt;&lt; std::endl;</code></p>
  </li>
  <li><code>size_type capacity()</code>
    <p>Returns total number of elements currently able to be stored in
    container without expansion.<br>
    Example: <code style="color: brown">std::cout &lt;&lt; i_colony.capacity()
    &lt;&lt; std::endl;</code></p>
  </li>
  <li><code>void shrink_to_fit()</code> 
    <p>Reduces container capacity to the amount necessary to store all
    currently stored elements. If the total number of elements is larger than
    the maximum group size, the resultant capacity will be equal to
    <code>((total_elements / max_group_size) + 1) * max_group_size</code>
    (rounding down at division). Invalidates all pointers, iterators and
    references to elements within the container.<br>
    Example: <code style="color: brown">i_colony.shrink_to_fit();</code></p>
  </li>
  <li><code>void reserve(unsigned short reserve_amount)</code> 
    <p>Preallocates memory space sufficient to store the number of elements
    indicated by <code>reserve_amount</code>. The maximum size for this number
    is limited to the maximum group size of the colony and will be truncated if
    necessary. The default maximum group size is 65535 on the majority of
    platforms.<br>
    Example: <code style="color: brown">i_colony.reserve(15);</code></p>
  </li>
  <li><code>void clear()</code>
    <p>Empties the colony and removes all elements and groups.<br>
    Example: <code style="color: brown">object_colony.clear();</code></p>
  </li>
  <li><code>void change_group_sizes(const unsigned short min_group_size, const
    unsigned short max_group_size)</code>
    <p>Changes the minimum and maximum internal group sizes, in terms of number
    of elements stored per group. If the colony is not empty and either min_group_size is larger than the smallest group in the colony, or max_group_size is smaller than the largest group in the colony, the colony will be internally copy-constructed into a new colony which uses the new group sizes, invalidating all pointers/iterators/references.<br>
    Example: <code style="color: brown">object_colony.change_group_sizes(1000,
    10000);</code></p>
  </li>
  <li><code>void change_minimum_group_size(const unsigned short
    min_group_size)</code>
    <p>Changes the minimum internal group size only, in terms of minimum number
    of elements stored per group. If the colony is not empty and min_group_size is larger than the smallest group in the colony, the colony will be internally copy-constructed into a new colony which uses the new minimum group size, invalidating all pointers/iterators/references.<br>
    Example: <code
    style="color: brown">object_colony.change_minimum_group_size(100);</code></p>
  </li>
  <li><code>void change_maximum_group_size(const unsigned short
    min_group_size)</code>
    <p>Changes the maximum internal group size only, in terms of maximum number
    of elements stored per group. If the colony is not empty and either max_group_size is smaller than the largest group in the colony, the colony will be internally copy-constructed into a new colony which uses the new maximum group size, invalidating all pointers/iterators/references.<br>
    Example: <code
    style="color: brown">object_colony.change_maximum_group_size(1000);</code></p>
  </li>
  <li><code>void reinitialize(const unsigned short min_group_size, const
    unsigned short max_group_size)</code>
    <p>Semantics of function are the same as "clear(); change_group_sizes(min_group_size, max_group_size);", but without the copy-construction code of the change_group_sizes() function - this means it can be used with element types which are non-copy-constructible, unlike change_group_sizes().<br>
    Example: <code style="color: brown">object_colony.reinitialize(1000,
    10000);</code></p>
  </li>
  <li><code>void swap(colony &amp;source)</code>
    <p>Swaps the colony's contents with that of <code>source</code>.<br>
    Example: <code
    style="color: brown">object_colony.swap(other_colony);</code></p>
  </li>
  <li><code>friend void swap(colony &amp;A, source &amp;B)</code>
    <p>External friend function, swaps the colony A's contents with that of
    colony B (assumes both stacks have same element type).<br>
    Example: <code style="color: brown">swap(object_colony,
    other_colony);</code></p>
  </li>
  <li><code>colony &amp; operator = (const colony &amp;source)</code> 
    <p>Copy the elements from another colony to this colony, clearing this
    colony of existing elements first.<br>
    Example: <code style="color: brown">// Manually swap data_colony1 and
    data_colony2 in C++03<br>
    data_colony3 = data_colony1;<br>
    data_colony1 = data_colony2;<br>
    data_colony2 = data_colony3;</code></p>
  </li>
  <li><code>colony &amp; operator = (const colony &amp;&amp;source) <b>C++11
    only</b></code> 
    <p>Move the elements from another colony to this colony, clearing this
    colony of existing elements first. Source colony becomes invalid but can be
    safely destructed without undefined behaviour.<br>
    Example: <code style="color: brown">// Manually swap data_colony1 and
    data_colony2 in C++11<br>
    data_colony3 = std::move(data_colony1);<br>
    data_colony1 = std::move(data_colony2);<br>
    data_colony2 = std::move(data_colony3);</code></p>
  </li>
  <li><code>bool operator == (const colony &amp;source)</code>
    <p>Compare contents of another colony to this colony. Returns a boolean as
    to whether they are equal.<br>
    Example: <code style="color: brown">if (object_colony == object_colony2)
    return;</code></p>
  </li>
  <li><code>bool operator != (const colony &amp;source)</code>
    <p>Compare contents of another colony to this colony. Returns a boolean as
    to whether they are not equal.<br>
    Example: <code style="color: brown">if (object_colony != object_colony2)
    return;</code></p>
  </li>
  <li><code>iterator begin(), iterator end(), const_iterator cbegin(),
    const_iterator cend()</code>
    <p>Return iterators pointing to, respectively, the first element of the
    colony and the element one-past the end of the colony (as per standard STL
    guidelines).</p>
  </li>
  <li><code>reverse_iterator rbegin(), reverse_iterator rend(),
    const_reverse_iterator cbegin(), const_reverse_iterator cend()</code>
    <p>Return reverse iterators pointing to, respectively, the last element of
    the colony and the element one-before the first element of the colony (as
    per standard STL guidelines).</p>
  </li>
  <li><code>iterator get_iterator_from_pointer(const element_pointer_type the_pointer) <b>(slow)</b></code>
    <p>Getting a pointer from an iterator is simple - simply dereference it then grab the address ie. <code>"&(*the_iterator);"</code>.
    Getting an iterator from a pointer is typically not so simple. This function enables the user to do exactly that.
    This is expected to be useful in the use-case where external
    containers are storing pointers to colony elements instead of iterators (as
    iterators have 3 times the size of an element pointer) and the program
    wants to erase the element being pointed to or possibly change the element being pointed to.
	 Converting a pointer to an iterator using this method and then erasing, is about 20%
    slower on average than erasing when you already have the iterator. This is less dramatic than it sounds, as it is still faster than all std:: container erasure times except std::list, which it is roughly equal
    to. However this is generally a slower, lookup-based operation.
	If the lookup doesn't find a non-erased element based on that pointer, it returns <code>end()</code>. Otherwise it returns an iterator pointing to the element in question. Example:</p>
    <p><code style="color: brown">plf::colony&lt;a_struct&gt; data_colony;<br>
    plf::colony&lt;a_struct&gt;::iterator an_iterator;<br>
    a_struct struct_instance;<br>
    an_iterator = data_colony.insert(struct_instance);<br>
    a_struct *struct_pointer = &amp;(*an_iterator);<br>
	iterator another_iterator = data_colony.get_iterator_from_pointer(struct_pointer);<br>
    if (an_iterator == another_iterator) std::cout &lt;&lt; "Iterator is correct" &lt;&lt;
    std::endl;</code> </p>
  </li>
  <li><code>size_type get_index_from_iterator(const iterator/const_iterator &amp;the_iterator) <b>(slow)</b></code>
    <p>While colony is a container with unordered insertion (and is therefore unordered), it still has a (transitory) order which changes frequently upon erasure and insertion. <i>Temporary</i> index numbers are therefore obtainable. These can be useful, for example, when creating a save file in a computer game, where certain elements in a container may need to be re-linked to other elements in other container upon reloading the save file. Example:</p>
    <p><code style="color: brown">plf::colony&lt;a_struct&gt; data_colony;<br>
    plf::colony&lt;a_struct&gt;::iterator an_iterator;<br>
    a_struct struct_instance;<br>
    data_colony.insert(struct_instance);<br>
    data_colony.insert(struct_instance);<br>
    an_iterator = data_colony.insert(struct_instance);<br>
    unsigned int index = data_colony.get_index_from_iterator(an_iterator);<br>
    if (index == 2) std::cout &lt;&lt; "Index is correct" &lt;&lt;
    std::endl;</code> </p>
  </li>
  <li><code>size_type get_index_from_reverse_iterator(const reverse_iterator/const_reverse_iterator &amp;the_iterator) <b>(slow)</b></code>
    <p>The same as get_index_from_iterator, but for reverse_iterators and const_reverse_iterators. Index is from front of colony (same as iterator), not back of colony. Example:</p>
    <p><code style="color: brown">plf::colony&lt;a_struct&gt; data_colony;<br>
    plf::colony&lt;a_struct&gt;::reverse_iterator r_iterator;<br>
    a_struct struct_instance;<br>
    data_colony.insert(struct_instance);<br>
    data_colony.insert(struct_instance);<br>
    r_iterator = data_colony.rend();<br>
    unsigned int index = data_colony.get_index_from_reverse_iterator(r_iterator);<br>
    if (index == 1) std::cout &lt;&lt; "Index is correct" &lt;&lt;
    std::endl;</code> </p>
  </li>
  <li><code>iterator get_iterator_from_index(const size_type index) <b>(slow)</b></code>
    <p>As described above, there may be situations where obtaining iterators to specific elements based on an index can be useful, for example, when reloading save files. This function is basically a shorthand to avoid typing <code>"iterator it = colony.begin(); colony.advance(it, 50);"</code>. Example:</p>
    <p><code style="color: brown">plf::colony&lt;a_struct&gt; data_colony;<br>
    plf::colony&lt;a_struct&gt;::iterator an_iterator;<br>
    a_struct struct_instance;<br>
    data_colony.insert(struct_instance);<br>
    data_colony.insert(struct_instance);<br>
    iterator an_iterator = data_colony.insert(struct_instance);<br>
    iterator another_iterator = data_colony.get_iterator_from_index(2);<br>
    if (an_iterator == another_iterator) std::cout &lt;&lt; "Iterator is correct" &lt;&lt;
    std::endl;</code> </p>
  </li>


</ul>
<!-- <h3>Non-member functions</h3> -->
<ul>
  <li><code>template &lt;iterator_type&gt; void advance(iterator_type iterator,
    distance_type distance)</code>
    <p>Increments/decrements the iterator supplied by the positive or negative
    amount indicated by <i>distance</i>. Speed of incrementation will almost
    always be faster than using the ++ operator on the iterator for increments
    greater than 1. In some cases it may approximate O(1). The iterator_type
    can be an iterator, const_iterator, reverse_iterator or
    const_reverse_iterator.<br>
    Example: <code style="color: brown">colony&lt;int&gt;::iterator it =
    i_colony.begin();<br>
    i_colony.advance(it, 20); </code></p>
  </li>
  <li><code>template &lt;iterator_type&gt; iterator_type next(const
    iterator_type &amp;iterator, distance_type distance)</code> 
    <p>Creates a copy of the iterator supplied, then increments/decrements this
    iterator by the positive or negative amount indicated by
    <i>distance</i>.<br>
    Example: <code style="color: brown">colony&lt;int&gt;::iterator it =
    i_colony.next(i_colony.begin(), 20);</code></p>
  </li>
  <li><code>template &lt;iterator_type&gt; iterator_type prev(const
    iterator_type &amp;iterator, distance_type distance)</code> 
    <p>Creates a copy of the iterator supplied, then decrements/increments this
    iterator by the positive or negative amount indicated by
    <i>distance</i>.<br>
    Example: <code style="color: brown">colony&lt;int&gt;::iterator it2 =
    i_colony.prev(i_colony.end(), 20);</code></p>
  </li>
  <li><code>template &lt;iterator_type&gt; difference_type distance(const
    iterator_type &amp;first, const iterator_type &amp;last)</code> 
    <p>Measures the distance between two iterators, returning the result, which
    will be negative if the second iterator supplied is before the first
    iterator supplied in terms of it's location in the colony.<br>
    Example: <code style="color: brown">colony&lt;int&gt;::iterator it =
    i_colony.next(i_colony.begin(), 20);<br>
    colony&lt;int&gt;::iterator it2 = i_colony.prev(i_colony.end(), 20);<br>
    std::cout "Distance: " i_colony.distance(it, it2) std::endl;</code></p>
  </li>
</ul>

</html>
