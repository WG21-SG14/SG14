/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#pragma once

// This is an implementation of the proposed "std::flat_map" as specified in
// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0429r6.pdf
// except that it stores `vector<pair<K,V>>` instead of `vector<K>, vector<V>`.
// This results in a slightly different API around the edges, but it's essentially
// a drop-in replacement.
// Unfortunately we cannot eliminate the wacky iterators! This is because the
// elements are stored in a user-provided container and we can't be sure whether
// the value_type of that container is actually pair<K,V>. After all, we ourselves
// advertise a value_type of pair<K,V> but we don't have pair<K,V> objects living
// anywhere addressable.

#include <stddef.h>
#include <algorithm>
#include <functional>
#include <initializer_list>
#include <iterator>
#include <tuple>
#include <vector>

namespace stdext {

namespace flatmap_detail {
    template<class T, class = void> struct qualifies_as_range : std::false_type {};
    template<class T> struct qualifies_as_range<T, decltype(
        std::begin( std::declval<T()>()() ), void(),
        std::end( std::declval<T()>()() ), void()
    )> : std::true_type {};

    template<class It>
    using is_random_access_iterator = std::is_convertible<
        typename std::iterator_traits<It>::iterator_category,
        std::random_access_iterator_tag
    >;

    template<int I> struct priority_tag : priority_tag<I-1> {};
    template<> struct priority_tag<0> {};

    // As proposed in P0591R4. Guaranteed copy elision makes this do the right thing.
    template<class T, class Alloc, class... Args, class = std::enable_if_t<
        std::uses_allocator<T, Alloc>::value && std::is_constructible<T, std::allocator_arg_t, const Alloc&, Args&&...>::value
    >>
    T make_obj_using_allocator_(priority_tag<3>, const Alloc& alloc, Args&&... args) {
        return T(std::allocator_arg, alloc, static_cast<Args&&>(args)...);
    }
    template<class T, class Alloc, class... Args, class = std::enable_if_t<
        std::uses_allocator<T, Alloc>::value && std::is_constructible<T, Args&&..., const Alloc&>::value
    >>
    T make_obj_using_allocator_(priority_tag<2>, const Alloc& alloc, Args&&... args) {
        return T(static_cast<Args&&>(args)..., alloc);
    }
    template<class T, class Alloc, class... Args, class = std::enable_if_t<
        !std::uses_allocator<T, Alloc>::value && std::is_constructible<T, Args&&...>::value
    >>
    T make_obj_using_allocator_(priority_tag<1>, const Alloc&, Args&&... args) {
        return T(static_cast<Args&&>(args)...);
    }
    template<class T, class Alloc, class... Args>
    T make_obj_using_allocator_(priority_tag<0>, const Alloc&, Args&&...) {
        static_assert(sizeof(T)==0, "this request for uses-allocator construction is ill-formed");
    }
    template<class T, class Alloc, class... Args>
    T make_obj_using_allocator(const Alloc& alloc, Args&&... args) {
        return make_obj_using_allocator_<T>(priority_tag<3>(), alloc, static_cast<Args&&>(args)...);
    }

    template<class Container>
    using cont_key_type = std::remove_const_t<typename Container::value_type::first_type>;

    template<class Container>
    using cont_mapped_type = typename Container::value_type::second_type;

    template<class InputIterator>
    using iter_key_type = std::remove_const_t<typename std::iterator_traits<InputIterator>::value_type::first_type>;

    template<class InputIterator>
    using iter_mapped_type = typename std::iterator_traits<InputIterator>::value_type::second_type;

    template<class...> using void_t = void;

    template<class A, class = void>
    struct qualifies_as_allocator : std::false_type {};
    template<class A>
    struct qualifies_as_allocator<A, void_t<
        typename A::value_type,
        decltype(std::declval<A&>().allocate(size_t{}))
    >> : std::true_type {};

    template<class It>
    using qualifies_as_input_iterator = std::integral_constant<bool, !std::is_integral<It>::value>;

    template<class, class> class iter;
    template<class I, class CKR> iter<I, CKR> make_iterator(I);

    template<class Reference>
    struct arrow_proxy {
        Reference *operator->() { return std::addressof(data_); }

        template<class, class> friend class iter;

        Reference data_;
    };

    template<class It, class ConstKeyReference>
    class iter {
    public:
        using difference_type = ptrdiff_t;
        using value_type = typename std::iterator_traits<It>::value_type;
        using reference = std::pair<
            ConstKeyReference,
            decltype(((*std::declval<It>()).second))
        >;
        using pointer = arrow_proxy<reference>;
        using iterator_category = std::random_access_iterator_tag;

        iter() = default;
        iter(iter&&) = default;
        iter(const iter&) = default;
        iter& operator=(iter&&) = default;
        iter& operator=(const iter&) = default;
        ~iter() = default;

        // This is the iterator-to-const_iterator implicit conversion.
        template<class I,
                 class = std::enable_if_t<std::is_convertible<I, It>::value>>
        iter(const iter<I, ConstKeyReference>& other) : it_(other.private_impl()) {}

        reference operator*() const {
            return reference{*it_};
        }

        pointer operator->() const {
            return arrow_proxy<reference>{reference{*it_}};
        }

        iter& operator++() { ++it_; return *this; }
        iter& operator--() { --it_; return *this; }
        iter operator++(int) { iter result(*this); ++*this; return result; }
        iter operator--(int) { iter result(*this); --*this; return result; }
        iter& operator+=(ptrdiff_t n) { it_ += n; return *this; }
        iter& operator-=(ptrdiff_t n) { it_ -= n; return *this; }
        reference operator[](ptrdiff_t n) const { return *(*this + n); }
        friend iter operator+(iter it, ptrdiff_t n) { it += n; return it; }
        friend iter operator+(ptrdiff_t n, iter it) { it += n; return it; }
        friend iter operator-(iter it, ptrdiff_t n) { it -= n; return it; }
        friend ptrdiff_t operator-(const iter& it, const iter& jt) { return ptrdiff_t(it.it_ - jt.it_); }
        friend bool operator==(const iter& a, const iter& b) { return a.it_ == b.it_; }
        friend bool operator!=(const iter& a, const iter& b) { return !(a.it_ == b.it_); }
        friend bool operator<(const iter& a, const iter& b) { return a.it_ < b.it_; }
        friend bool operator<=(const iter& a, const iter& b) { return !(b.it_ < a.it_); }
        friend bool operator>(const iter& a, const iter& b) { return b.it_ < a.it_; }
        friend bool operator>=(const iter& a, const iter& b) { return !(a.it_ < b.it_); }

        It private_impl() const { return it_; }

    private:
        template<class I, class CKR>
        friend iter<I, CKR> make_iterator(I);

        explicit iter(It&& it)
            : it_(static_cast<It&&>(it)) {}
        It it_;
    };

    template<class I, class CKR>
    iter<I, CKR> make_iterator(I it) {
        return iter<I, CKR>(static_cast<I&&>(it));
    }

} // namespace flatmap_detail

#ifndef STDEXT_HAS_SORTED_UNIQUE
#define STDEXT_HAS_SORTED_UNIQUE

struct sorted_unique_t { explicit sorted_unique_t() = default; };

#if defined(__cpp_inline_variables)
inline
#endif
constexpr sorted_unique_t sorted_unique {};

#endif // STDEXT_HAS_SORTED_UNIQUE

template<
    class Key,
    class Mapped,
    class Compare = std::less<Key>,
    class PairContainer = std::vector<std::pair<Key, Mapped>>
>
class flat_map {
    static_assert(flatmap_detail::is_random_access_iterator<typename PairContainer::iterator>::value, "");
    static_assert(std::is_same<typename PairContainer::value_type, std::pair<Key, Mapped>>::value, "");
    static_assert(!std::is_const<PairContainer>::value, "");
    static_assert(!std::is_const<Key>::value, "");
    static_assert(!std::is_const<Mapped>::value, "");
    static_assert(!std::is_reference<Key>::value, "");
    static_assert(!std::is_reference<Mapped>::value, "");
    static_assert(std::is_convertible<decltype(std::declval<const Compare&>()(std::declval<const Key&>(), std::declval<const Key&>())), bool>::value, "");

public:
    using key_type = Key;
    using mapped_type = Mapped;
    using value_type = std::pair<Key, Mapped>;
    using key_compare = Compare;
    using const_key_reference = decltype(((*std::declval<typename PairContainer::const_iterator>()).first));
    using mapped_reference = decltype(((*std::declval<typename PairContainer::iterator>()).second));
    using const_mapped_reference = decltype(((*std::declval<typename PairContainer::const_iterator>()).second));
    using reference = std::pair<const_key_reference, mapped_reference>;
    using const_reference = std::pair<const_key_reference, const_mapped_reference>;
    using size_type = typename PairContainer::size_type;
    using difference_type = typename PairContainer::difference_type;
    using iterator = flatmap_detail::iter<typename PairContainer::iterator, const_key_reference>;
    using const_iterator = flatmap_detail::iter<typename PairContainer::const_iterator, const_key_reference>;
    using reverse_iterator = std::reverse_iterator<iterator>;
    using const_reverse_iterator = std::reverse_iterator<const_iterator>;
    using container_type = PairContainer;

    class value_compare {
        friend class flat_map;
    protected:
        // TODO: this should be private
        Compare comp;
        // TODO: this constructor should be explicit
        value_compare(Compare c): comp(c) {}
    public:
        bool operator()(const_reference x, const_reference y) const {
            return comp(x.first, y.first);
        }
    };

private:
    template<class It>
    static flatmap_detail::iter<It, const_key_reference> make_iterator(It it) {
        return flatmap_detail::make_iterator<It, const_key_reference>(it);
    }

public:

// =========================================================== CONSTRUCTORS
// This is all one massive overload set!

    flat_map() : flat_map(Compare()) {}

    template<class Container,
             std::enable_if_t<flatmap_detail::qualifies_as_range<const Container&>::value, int> = 0>
    explicit flat_map(const Container& cont)
        : flat_map(std::begin(cont), std::end(cont), Compare()) {}

    template<class Container,
             std::enable_if_t<flatmap_detail::qualifies_as_range<const Container&>::value, int> = 0>
    explicit flat_map(const Container& cont, const Compare& comp)
        : flat_map(std::begin(cont), std::end(cont), comp) {}

    template<class Container, class Alloc,
             class = std::enable_if_t<flatmap_detail::qualifies_as_range<const Container&>::value && std::uses_allocator<PairContainer, Alloc>::value>>
    flat_map(const Container& cont, const Alloc& a)
        : flat_map(std::begin(cont), std::end(cont), Compare(), a) {}

    template<class Container, class Alloc,
             class = std::enable_if_t<flatmap_detail::qualifies_as_range<const Container&>::value && std::uses_allocator<PairContainer, Alloc>::value>>
    flat_map(const Container& cont, const Compare& comp, const Alloc& a)
        : flat_map(std::begin(cont), std::end(cont), comp, a) {}

    template<class Container,
             class = std::enable_if_t<flatmap_detail::qualifies_as_range<const Container&>::value>>
    flat_map(sorted_unique_t s, const Container& cont)
        : flat_map(s, std::begin(cont), std::end(cont), Compare()) {}

    template<class Container,
             class = std::enable_if_t<flatmap_detail::qualifies_as_range<const Container&>::value>>
    flat_map(sorted_unique_t s, const Container& cont, const Compare& comp)
        : flat_map(s, std::begin(cont), std::end(cont), comp) {}

    template<class Container, class Alloc,
             class = std::enable_if_t<flatmap_detail::qualifies_as_range<const Container&>::value && std::uses_allocator<PairContainer, Alloc>::value>>
    flat_map(sorted_unique_t s, const Container& cont, const Alloc& a)
        : flat_map(s, std::begin(cont), std::end(cont), Compare(), a) {}

    template<class Container, class Alloc,
             class = std::enable_if_t<flatmap_detail::qualifies_as_range<const Container&>::value && std::uses_allocator<PairContainer, Alloc>::value>>
    flat_map(sorted_unique_t s, const Container& cont, const Compare& comp, const Alloc& a)
        : flat_map(s, std::begin(cont), std::end(cont), comp, a) {}

    explicit flat_map(const Compare& comp)
        : compare_(comp) {}

    template<class Alloc,
             std::enable_if_t<std::uses_allocator<PairContainer, Alloc>::value, int> = 0>
    flat_map(const Compare& comp, const Alloc& a)
        : c_(a), compare_(comp) {}

    template<class Alloc,
             std::enable_if_t<std::uses_allocator<PairContainer, Alloc>::value, int> = 0>
    explicit flat_map(const Alloc& a)
        : flat_map(Compare(), a) {}

    // TODO: shouldn't InputIterator be constrained to point to something with "first" and "second" members?
    template<class InputIterator,
             class = std::enable_if_t<flatmap_detail::qualifies_as_input_iterator<InputIterator>::value>>
    flat_map(InputIterator first, InputIterator last, const Compare& comp = Compare())
        : compare_(comp)
    {
        for (; first != last; ++first) {
            c_.emplace(c_.end(), *first);
        }
        std::sort(c_.begin(), c_.end(), [&](const auto& a, const auto& b) {
            return bool(compare_(a.first, b.first));
        });
    }

    template<class InputIterator, class Alloc,
             class = std::enable_if_t<flatmap_detail::qualifies_as_input_iterator<InputIterator>::value && std::uses_allocator<PairContainer, Alloc>::value>>
    flat_map(InputIterator first, InputIterator last, const Compare& comp, const Alloc& a)
        : c_(a), compare_(comp)
    {
        for (; first != last; ++first) {
            c_.emplace(c_.end(), *first);
        }
        std::sort(c_.begin(), c_.end(), [&](const auto& a, const auto& b) {
            return bool(compare_(a.first, b.first));
        });
    }

    template<class InputIterator, class Alloc,
             class = std::enable_if_t<flatmap_detail::qualifies_as_input_iterator<InputIterator>::value && std::uses_allocator<PairContainer, Alloc>::value>>
    flat_map(InputIterator first, InputIterator last, const Alloc& a)
        : flat_map(first, last, Compare(), a) {}

    template<class InputIterator,
             class = std::enable_if_t<flatmap_detail::qualifies_as_input_iterator<InputIterator>::value>>
    flat_map(sorted_unique_t, InputIterator first, InputIterator last, const Compare& comp = Compare())
        : compare_(comp)
    {
        for (; first != last; ++first) {
            c_.emplace(c_.end(), *first);
        }
    }

    template<class InputIterator, class Alloc,
             class = std::enable_if_t<flatmap_detail::qualifies_as_input_iterator<InputIterator>::value && std::uses_allocator<PairContainer, Alloc>::value>>
    flat_map(sorted_unique_t, InputIterator first, InputIterator last, const Compare& comp, const Alloc& a)
        : c_(a), compare_(comp)
    {
        for (; first != last; ++first) {
            c_.emplace(c_.end(), *first);
        }
    }

    template<class InputIterator, class Alloc,
             class = std::enable_if_t<flatmap_detail::qualifies_as_input_iterator<InputIterator>::value && std::uses_allocator<PairContainer, Alloc>::value>>
    flat_map(sorted_unique_t s, InputIterator first, InputIterator last, const Alloc& a)
        : flat_map(s, first, last, Compare(), a) {}

    // TODO: should this be conditionally noexcept?
    // TODO: surely this should use uses-allocator construction
    template<class Alloc,
             std::enable_if_t<std::uses_allocator<PairContainer, Alloc>::value, int> = 0>
    flat_map(flat_map&& m, const Alloc& a)
        : c_(static_cast<PairContainer&&>(m.c_), a), compare_(std::move(m.compare_)) {}

    // TODO: surely this should use uses-allocator construction
    template<class Alloc,
             std::enable_if_t<std::uses_allocator<PairContainer, Alloc>::value, int> = 0>
    flat_map(const flat_map& m, const Alloc& a)
        : c_(m.c_, a), compare_{m.compare_} {}

    flat_map(std::initializer_list<value_type>&& il, const Compare& comp = Compare())
        : flat_map(il, comp) {}

    template<class Alloc,
             std::enable_if_t<std::uses_allocator<PairContainer, Alloc>::value, int> = 0>
    flat_map(std::initializer_list<value_type>&& il, const Compare& comp, const Alloc& a)
        : flat_map(il, comp, a) {}

    template<class Alloc,
             std::enable_if_t<std::uses_allocator<PairContainer, Alloc>::value, int> = 0>
    flat_map(std::initializer_list<value_type>&& il, const Alloc& a)
        : flat_map(il, Compare(), a) {}

    flat_map(sorted_unique_t s, std::initializer_list<value_type>&& il, const Compare& comp = Compare())
        : flat_map(s, il, comp) {}

    template<class Alloc,
             std::enable_if_t<std::uses_allocator<PairContainer, Alloc>::value, int> = 0>
    flat_map(sorted_unique_t s, std::initializer_list<value_type>&& il, const Compare& comp, const Alloc& a)
        : flat_map(s, il, comp, a) {}

    template<class Alloc,
             std::enable_if_t<std::uses_allocator<PairContainer, Alloc>::value, int> = 0>
    flat_map(sorted_unique_t s, std::initializer_list<value_type>&& il, const Alloc& a)
        : flat_map(s, il, Compare(), a) {}

// ========================================================== OTHER MEMBERS

    flat_map& operator=(std::initializer_list<value_type> il) {
        this->clear();
        this->insert(il);
        return *this;
    }

    iterator begin() noexcept { return make_iterator(c_.begin()); }
    const_iterator begin() const noexcept { return make_iterator(c_.begin()); }
    iterator end() noexcept { return make_iterator(c_.end()); }
    const_iterator end() const noexcept { return make_iterator(c_.end()); }
    const_iterator cbegin() const noexcept { return make_iterator(c_.begin()); }
    const_iterator cend() const noexcept { return make_iterator(c_.end()); }

    reverse_iterator rbegin() noexcept { return std::make_reverse_iterator(end()); }
    const_reverse_iterator rbegin() const noexcept { return std::make_reverse_iterator(end()); }
    reverse_iterator rend() noexcept { return std::make_reverse_iterator(begin()); }
    const_reverse_iterator rend() const noexcept { return std::make_reverse_iterator(begin()); }

    const_reverse_iterator crbegin() const noexcept { return std::make_reverse_iterator(begin()); }
    const_reverse_iterator crend() const noexcept { return std::make_reverse_iterator(end()); }

#if __cplusplus >= 201703L
    [[nodiscard]]
#endif
    bool empty() const noexcept { return c_.empty(); }
    size_type size() const noexcept { return c_.size(); }
    size_type max_size() const noexcept { return c_.max_size(); }

    mapped_reference operator[](const Key& x) {
        return try_emplace(x).first->second;
    }

    mapped_reference operator[](Key&& x) {
        return try_emplace(static_cast<Key&&>(x)).first->second;
    }

    mapped_reference at(const Key& k) {
        auto it = this->find(k);
        if (it == end()) {
            throw std::out_of_range("flat_map::at");
        }
        return it->second;
    }

    const_mapped_reference at(const Key& k) const {
        auto it = this->find(k);
        if (it == end()) {
            throw std::out_of_range("flat_map::at");
        }
        return it->second;
    }

    template<class... Args, class = decltype(std::pair<Key, Mapped>(std::declval<Args&&>()...), void())>
    std::pair<iterator, bool> emplace(Args&&... args) {
        std::pair<Key, Mapped> t(static_cast<Args&&>(args)...);
        auto it = this->lower_bound(t.first).private_impl();
        if (it == c_.end() || compare_(t.first, it->first)) {
            it = c_.emplace(it, static_cast<std::pair<Key, Mapped>&&>(t));
            return {make_iterator(it), true};
        } else {
            return {make_iterator(it), false};
        }
    }

    // TODO: this function cannot possibly meet its amortized-constant-complexity requirement
    template<class... Args>
    iterator emplace_hint(const_iterator, Args&&... args) {
        return this->emplace(static_cast<Args&&>(args)...).first;
    }

    std::pair<iterator, bool> insert(const value_type& x) {
        return this->emplace(x);
    }

    std::pair<iterator, bool> insert(value_type&& x) {
        return this->emplace(static_cast<value_type&&>(x));
    }

    template<class P,
             class = decltype(std::pair<Key, Mapped>(std::declval<P&&>()))>
    std::pair<iterator, bool> insert(P&& x) {
        return this->emplace(static_cast<P&&>(x));
    }

    iterator insert(const_iterator position, const value_type& x) {
        return this->emplace_hint(position, x);
    }

    iterator insert(const_iterator position, value_type&& x) {
        return this->emplace_hint(position, static_cast<value_type&&>(x));
    }

    template<class P,
             class = decltype(std::pair<Key, Mapped>(std::declval<P&&>()))>
    iterator insert(const_iterator position, P&& x) {
        return this->emplace_hint(position, static_cast<P&&>(x));
    }

    template<class InputIterator,
             class = std::enable_if_t<flatmap_detail::qualifies_as_input_iterator<InputIterator>::value>>
    void insert(InputIterator first, InputIterator last) {
        while (first != last) {
            this->insert(*first);
            ++first;
        }
    }

    template<class InputIterator,
             class = std::enable_if_t<flatmap_detail::qualifies_as_input_iterator<InputIterator>::value>>
    void insert(stdext::sorted_unique_t, InputIterator first, InputIterator last) {
        auto it = begin();
        while (first != last) {
            std::pair<Key, Mapped> t(*first);
            it = std::partition_point(it, this->end(), [&](const auto& elt) {
                return bool(compare_(elt.first, t.first));
            });
            if (it == this->end() || compare_(t.first, it->first)) {
                it = this->emplace(it, std::move(t));
            }
            ++it;
            ++first;
        }
    }

    void insert(std::initializer_list<value_type> il) {
        this->insert(il.begin(), il.end());
    }

    void insert(stdext::sorted_unique_t s, std::initializer_list<value_type> il) {
        this->insert(s, il.begin(), il.end());
    }

    PairContainer extract() && {
        return static_cast<PairContainer&&>(c_);
    }

    void replace(PairContainer&& c) {
        c_ = static_cast<PairContainer&&>(c);
    }

    template<class... Args>
    std::pair<iterator, bool> try_emplace(const Key& k, Args&&... args) {
        auto it = std::partition_point(
            c_.begin(), c_.end(),
            [&](const auto& elt) {
                return bool(compare_(elt.first, k));
            }
        );
        if (it == c_.end() || compare_(k, it->first)) {
            it = c_.emplace(it, std::piecewise_construct,
                std::tuple<const Key&>(k),
                std::tuple<Args&&...>(static_cast<Args&&>(args)...)
            );
            return {make_iterator(it), true};
        } else {
            return {make_iterator(it), false};
        }
    }

    template<class... Args>
    std::pair<iterator, bool> try_emplace(Key&& k, Args&&... args) {
        auto it = std::partition_point(
            c_.begin(), c_.end(),
            [&](const auto& elt) {
                return bool(compare_(elt.first, k));
            }
        );
        if (it == c_.end() || compare_(k, it->first)) {
            it = c_.emplace(it, std::piecewise_construct,
                std::tuple<Key&&>(static_cast<Key&&>(k)),
                std::tuple<Args&&...>(static_cast<Args&&>(args)...)
            );
            return {make_iterator(it), true};
        } else {
            return {make_iterator(it), false};
        }
    }

    // TODO: use the hint, here
    template<class... Args>
    iterator try_emplace(const_iterator, const Key& k, Args&&... args) {
        return try_emplace(k, static_cast<Args&&>(args)...).first;
    }

    // TODO: use the hint, here
    template<class... Args>
    iterator try_emplace(const_iterator, Key&& k, Args&&... args) {
        return try_emplace(static_cast<Key&&>(k), static_cast<Args&&>(args)...).first;
    }

    template<class M>
    std::pair<iterator, bool> insert_or_assign(const Key& k, M&& obj) {
        static_assert(std::is_assignable<Mapped&, M>::value, "");
        static_assert(sizeof( Mapped(static_cast<M&&>(obj)) ) != 0, "");
        auto result = try_emplace(k, static_cast<M&&>(obj));
        if (!result.second) {
            result.first->second = static_cast<M&&>(obj);
        }
        return result;
    }

    template<class M>
    std::pair<iterator, bool> insert_or_assign(Key&& k, M&& obj) {
        static_assert(std::is_assignable<Mapped&, M>::value, "");
        static_assert(sizeof( Mapped(static_cast<M&&>(obj)) ) != 0, "");
        auto result = try_emplace(static_cast<Key&&>(k), static_cast<M&&>(obj));
        if (!result.second) {
            result.first->second = static_cast<M&&>(obj);
        }
        return result;
    }

    // TODO: use the hint, here
    template<class M>
    iterator insert_or_assign(const_iterator, const Key& k, M&& obj) {
        static_assert(std::is_assignable<Mapped&, M>::value, "");
        static_assert(sizeof( Mapped(static_cast<M&&>(obj)) ) != 0, "");
        auto result = try_emplace(k, static_cast<M&&>(obj));
        if (!result.second) {
            result.first->second = static_cast<M&&>(obj);
        }
        return result.first;
    }

    // TODO: use the hint, here
    template<class M>
    iterator insert_or_assign(const_iterator, Key&& k, M&& obj) {
        static_assert(std::is_assignable<Mapped&, M>::value, "");
        static_assert(sizeof( Mapped(static_cast<M&&>(obj)) ) != 0, "");
        auto result = try_emplace(static_cast<Key&&>(k), static_cast<M&&>(obj));
        if (!result.second) {
            result.first->second = static_cast<M&&>(obj);
        }
        return result.first;
    }

    iterator erase(iterator position) {
        auto itmut = c_.erase(position.private_impl());
        return make_iterator(itmut);
    }

    iterator erase(const_iterator position) {
        auto itmut = c_.erase(position.private_impl());
        return make_iterator(itmut);
    }

    size_type erase(const Key& k) {
        auto it = this->find(k);
        if (it != this->end()) {
            this->erase(it);
            return 1;
        }
        return 0;
    }

    iterator erase(const_iterator first, const_iterator last) {
        auto ifirst = first.private_impl();
        auto ilast = last.private_impl();
        auto itmut = c_.erase(ifirst, ilast);
        return make_iterator(itmut);
    }

    void swap(flat_map& fm) noexcept
#if defined(__cpp_lib_is_swappable)
        (std::is_nothrow_swappable<PairContainer>::value && std::is_nothrow_swappable<Compare>::value)
#endif
    {
        using std::swap;
        swap(c_, fm.c_);
        swap(compare_, fm.compare_);
    }

    void clear() noexcept {
        c_.clear();
    }

    key_compare key_comp() const {
        return compare_;
    }

    value_compare value_comp() const {
        return value_compare(compare_);
    }

    iterator find(const Key& k) {
        auto it = this->lower_bound(k);
        if (it == end() || compare_(k, it->first)) {
            return end();
        }
        return it;
    }

    const_iterator find(const Key& k) const {
        auto it = this->lower_bound(k);
        if (it == end() || compare_(k, it->first)) {
            return end();
        }
        return it;
    }

    template<class K,
             class Compare_ = Compare, class = typename Compare_::is_transparent>
    iterator find(const K& x) {
        auto it = this->lower_bound(x);
        if (it == end() || compare_(x, it->first)) {
            return end();
        }
        return it;
    }

    template<class K,
             class Compare_ = Compare, class = typename Compare_::is_transparent>
    const_iterator find(const K& x) const {
        auto it = this->lower_bound(x);
        if (it == end() || compare_(x, it->first)) {
            return end();
        }
        return it;
    }

    size_type count(const Key& k) const {
        return this->contains(k) ? 1 : 0;
    }

    template<class K,
             class Compare_ = Compare, class = typename Compare_::is_transparent>
    size_type count(const K& x) const {
        return this->contains(x) ? 1 : 0;
    }

    bool contains(const Key& k) const {
        return this->find(k) != this->end();
    }

    template<class K,
             class Compare_ = Compare, class = typename Compare_::is_transparent>
    bool contains(const K& x) const {
        return this->find(x) != this->end();
    }

    iterator lower_bound(const Key& k) {
        auto it = std::partition_point(c_.begin(), c_.end(), [&](const auto& elt) {
            return bool(compare_(elt.first, k));
        });
        return make_iterator(it);
    }

    const_iterator lower_bound(const Key& k) const {
        auto it = std::partition_point(c_.begin(), c_.end(), [&](const auto& elt) {
            return bool(compare_(elt.first, k));
        });
        return make_iterator(it);
    }

    template<class K,
             class Compare_ = Compare, class = typename Compare_::is_transparent>
    iterator lower_bound(const K& x) {
        auto it = std::partition_point(c_.begin(), c_.end(), [&](const auto& elt) {
            return bool(compare_(elt.first, x));
        });
        return make_iterator(it);
    }

    template<class K,
             class Compare_ = Compare, class = typename Compare_::is_transparent>
    const_iterator lower_bound(const K& x) const {
        auto it = std::partition_point(c_.begin(), c_.end(), [&](const auto& elt) {
            return bool(compare_(elt.first, x));
        });
        return make_iterator(it);
    }

    iterator upper_bound(const Key& k) {
        auto it = std::partition_point(c_.begin(), c_.end(), [&](const auto& elt) {
            return !bool(compare_(k, elt.first));
        });
        return make_iterator(it);
    }

    const_iterator upper_bound(const Key& k) const {
        auto it = std::partition_point(c_.begin(), c_.end(), [&](const auto& elt) {
            return !bool(compare_(k, elt.first));
        });
        return make_iterator(it);
    }

    template<class K,
             class Compare_ = Compare, class = typename Compare_::is_transparent>
    iterator upper_bound(const K& x) {
        auto it = std::partition_point(c_.begin(), c_.end(), [&](const auto& elt) {
            return !bool(compare_(x, elt.first));
        });
        return make_iterator(it);
    }

    template<class K,
             class Compare_ = Compare, class = typename Compare_::is_transparent>
    const_iterator upper_bound(const K& x) const {
        auto it = std::partition_point(c_.begin(), c_.end(), [&](const auto& elt) {
            return !bool(compare_(x, elt.first));
        });
        return make_iterator(it);
    }

    std::pair<iterator, iterator> equal_range(const Key& k) {
        auto lo = std::partition_point(c_.begin(), c_.end(), [&](const auto& elt) {
            return bool(compare_(elt.first, k));
        });
        auto hi = std::partition_point(lo, c_.end(), [&](const auto& elt) {
            return !bool(compare_(k, elt.first));
        });
        return {
            make_iterator(lo),
            make_iterator(hi)
        };
    }

    std::pair<const_iterator, const_iterator> equal_range(const Key& k) const {
        auto lo = std::partition_point(c_.begin(), c_.end(), [&](const auto& elt) {
            return bool(compare_(elt.first, k));
        });
        auto hi = std::partition_point(lo, c_.end(), [&](const auto& elt) {
            return !bool(compare_(k, elt.first));
        });
        return {
            make_iterator(lo),
            make_iterator(hi)
        };
    }

    template<class K,
             class Compare_ = Compare, class = typename Compare_::is_transparent>
    std::pair<iterator, iterator> equal_range(const K& x) {
        auto lo = std::partition_point(c_.begin(), c_.end(), [&](const auto& elt) {
            return bool(compare_(elt.first, x));
        });
        auto hi = std::partition_point(lo, c_.end(), [&](const auto& elt) {
            return !bool(compare_(x, elt.first));
        });
        return {
            make_iterator(lo),
            make_iterator(hi)
        };
    }

    template<class K,
             class Compare_ = Compare, class = typename Compare_::is_transparent>
    std::pair<const_iterator, const_iterator> equal_range(const K& x) const {
        auto lo = std::partition_point(c_.begin(), c_.end(), [&](const auto& elt) {
            return bool(compare_(elt.first, x));
        });
        auto hi = std::partition_point(lo, c_.end(), [&](const auto& elt) {
            return !bool(compare_(x, elt.first));
        });
        return {
            make_iterator(lo),
            make_iterator(hi)
        };
    }

private:
    PairContainer c_;
    Compare compare_;
};

// TODO: all six comparison operators should be invisible friends
template<class Key, class Mapped, class Compare, class Container>
bool operator==(const flat_map<Key, Mapped, Compare, Container>& x, const flat_map<Key, Mapped, Compare, Container>& y)
{
    return std::equal(x.begin(), x.end(), y.begin(), y.end());
}

template<class Key, class Mapped, class Compare, class Container>
bool operator!=(const flat_map<Key, Mapped, Compare, Container>& x, const flat_map<Key, Mapped, Compare, Container>& y)
{
    return !(x == y);
}

template<class Key, class Mapped, class Compare, class Container>
bool operator<(const flat_map<Key, Mapped, Compare, Container>& x, const flat_map<Key, Mapped, Compare, Container>& y)
{
    return std::lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());
}

template<class Key, class Mapped, class Compare, class Container>
bool operator>(const flat_map<Key, Mapped, Compare, Container>& x, const flat_map<Key, Mapped, Compare, Container>& y)
{
    return (y < x);
}

template<class Key, class Mapped, class Compare, class Container>
bool operator<=(const flat_map<Key, Mapped, Compare, Container>& x, const flat_map<Key, Mapped, Compare, Container>& y)
{
    return !(y < x);
}

template<class Key, class Mapped, class Compare, class Container>
bool operator>=(const flat_map<Key, Mapped, Compare, Container>& x, const flat_map<Key, Mapped, Compare, Container>& y)
{
    return !(x < y);
}

template<class Key, class Mapped, class Compare, class Container>
void swap(flat_map<Key, Mapped, Compare, Container>& x, flat_map<Key, Mapped, Compare, Container>& y) noexcept(noexcept(x.swap(y)))
{
    return x.swap(y);
}

#if defined(__cpp_deduction_guides)

// TODO: this deduction guide should maybe be constrained by qualifies_as_range
template<class Container,
         class = std::enable_if_t<!flatmap_detail::qualifies_as_allocator<Container>::value>>
flat_map(Container)
    -> flat_map<flatmap_detail::cont_key_type<Container>, flatmap_detail::cont_mapped_type<Container>, std::less<flatmap_detail::cont_key_type<Container>>, Container>;

template<class Container, class Allocator,
         class = std::enable_if_t<!flatmap_detail::qualifies_as_allocator<Container>::value && flatmap_detail::qualifies_as_allocator<Allocator>::value && std::uses_allocator<Container, Allocator>::value>>
flat_map(Container, Allocator, int=0/*to please MSVC*/)
    -> flat_map<flatmap_detail::cont_key_type<Container>, flatmap_detail::cont_mapped_type<Container>, std::less<flatmap_detail::cont_key_type<Container>>, Container>;

template<class Container,
         class = std::enable_if_t<!flatmap_detail::qualifies_as_allocator<Container>::value>>
flat_map(sorted_unique_t, Container)
    -> flat_map<flatmap_detail::cont_key_type<Container>, flatmap_detail::cont_mapped_type<Container>, std::less<flatmap_detail::cont_key_type<Container>>, Container>;

template<class Container, class Allocator,
         class = std::enable_if_t<!flatmap_detail::qualifies_as_allocator<Container>::value && flatmap_detail::qualifies_as_allocator<Allocator>::value && std::uses_allocator<Container, Allocator>::value>>
flat_map(sorted_unique_t, Container, Allocator, int=0/*to please MSVC*/)
    -> flat_map<flatmap_detail::cont_key_type<Container>, flatmap_detail::cont_mapped_type<Container>, std::less<flatmap_detail::cont_key_type<Container>>, Container>;

template<class InputIterator,
         class = std::enable_if_t<flatmap_detail::qualifies_as_input_iterator<InputIterator>::value>>
flat_map(InputIterator, InputIterator)
    -> flat_map<flatmap_detail::iter_key_type<InputIterator>, flatmap_detail::iter_mapped_type<InputIterator>, std::less<flatmap_detail::iter_key_type<InputIterator>>>;

template<class InputIterator, class Compare,
         class = std::enable_if_t<flatmap_detail::qualifies_as_input_iterator<InputIterator>::value && !flatmap_detail::qualifies_as_allocator<Compare>::value>>
flat_map(InputIterator, InputIterator, Compare)
    -> flat_map<flatmap_detail::iter_key_type<InputIterator>, flatmap_detail::iter_mapped_type<InputIterator>, Compare>;

template<class InputIterator,
         class = std::enable_if_t<flatmap_detail::qualifies_as_input_iterator<InputIterator>::value>>
flat_map(sorted_unique_t, InputIterator, InputIterator)
    -> flat_map<flatmap_detail::iter_key_type<InputIterator>, flatmap_detail::iter_mapped_type<InputIterator>, std::less<flatmap_detail::iter_key_type<InputIterator>>>;

template<class InputIterator, class Compare,
         class = std::enable_if_t<flatmap_detail::qualifies_as_input_iterator<InputIterator>::value && !flatmap_detail::qualifies_as_allocator<Compare>::value>>
flat_map(sorted_unique_t, InputIterator, InputIterator, Compare)
    -> flat_map<flatmap_detail::iter_key_type<InputIterator>, flatmap_detail::iter_mapped_type<InputIterator>, Compare>;

template<class Key, class T>
flat_map(std::initializer_list<std::pair<Key, T>>)
    -> flat_map<std::remove_const_t<Key>, T, std::less<std::remove_const_t<Key>>>;

template<class Key, class T, class Compare,
         class = std::enable_if_t<!flatmap_detail::qualifies_as_allocator<Compare>::value>>
flat_map(std::initializer_list<std::pair<Key, T>>, Compare)
    -> flat_map<std::remove_const_t<Key>, T, Compare>;

template<class Key, class T>
flat_map(sorted_unique_t, std::initializer_list<std::pair<Key, T>>)
    -> flat_map<std::remove_const_t<Key>, T, std::less<std::remove_const_t<Key>>>;

template<class Key, class T, class Compare,
         class = std::enable_if_t<!flatmap_detail::qualifies_as_allocator<Compare>::value>>
flat_map(sorted_unique_t, std::initializer_list<std::pair<Key, T>>, Compare)
    -> flat_map<std::remove_const_t<Key>, T, Compare>;

#endif

} // namespace stdext
